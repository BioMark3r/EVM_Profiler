<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>EVM Block Profiler â€“ Browser Runner (Providers+RPS+Backoff)</title>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap" rel="stylesheet">
  <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.1/dist/chart.umd.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/web3@1.10.4/dist/web3.min.js"></script>
  <style>
    :root { --bg:#0f1115; --panel:#171a21; --muted:#9aa4b2; --fg:#e5e7eb; --accent:#4f46e5; --card:#1f2430; --border:#2b3240; }
    * { box-sizing: border-box; }
    body { margin:0; padding:0 16px 60px; font-family:"Inter",system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif; background:linear-gradient(180deg,#0f1115,#0b0d11); color:var(--fg); }
    header { position:sticky; top:0; background:rgba(15,17,21,.8); backdrop-filter:blur(10px); z-index:10; padding:14px 0 10px; }
    .wrap { max-width: 1200px; margin: 0 auto; }
    h1 { margin:8px 0 0; font-size:22px; font-weight:700; letter-spacing:.2px; }
    p.small { color:var(--muted); margin:6px 0 0; font-size:13px; }
    .toolbar, .row { display:flex; gap:10px; align-items:center; flex-wrap:wrap; }
    .toolbar { margin:14px 0 0; }
    .box { display:flex; align-items:center; gap:8px; padding:10px 12px; border:1px solid var(--border); border-radius:10px; background:var(--panel); }
    input[type="text"], input[type="number"], select, textarea { padding:8px 10px; border-radius:8px; border:1px solid var(--border); background:#0c0f14; color:var(--fg); }
    input[type="text"] { width:520px; max-width:70vw; }
    textarea { width:100%; min-height: 72px; }
    .btn { border:1px solid var(--border); background:var(--panel); color:var(--fg); padding:10px 12px; border-radius:10px; cursor:pointer; }
    .btn.primary { background:var(--accent); border-color:#3f3ab6; }
    .status { color:var(--muted); font-size:12px; }
    .grid { display:grid; grid-template-columns: 1fr; gap:16px; margin-top:18px; }
    .panel { background:var(--card); border:1px solid var(--border); border-radius:14px; padding:16px; }
    .panel h2 { margin:0 0 10px; font-size:18px; }
    .kpis { display:grid; grid-template-columns: repeat(auto-fill, minmax(200px,1fr)); gap:12px; margin-top:12px; }
    .kpi { background: var(--card); border:1px solid var(--border); border-radius:14px; padding:14px; }
    .kpi .label { color: var(--muted); font-size:12px; }
    .kpi .value { font-size:22px; font-weight:700; margin-top:4px; }
    .flex { display:flex; gap:16px; flex-wrap: wrap; }
    .grow { flex:1; min-width: 320px; }
    table { width:100%; border-collapse: collapse; }
    th, td { padding:10px; border-bottom:1px solid var(--border); font-size: 13px; }
    th { text-align:left; color: var(--muted); font-weight:600; }
    tr:hover { background: rgba(255,255,255,0.03); }
    .pill { display:inline-block; padding:3px 8px; border-radius:999px; background: #0e7490; font-size:12px; }
    .muted { color: var(--muted); }
    .progress { height: 10px; background: #0c0f14; border:1px solid var(--border); border-radius: 8px; overflow: hidden; }
    .progress > div { height: 100%; background: var(--accent); width: 0%; }
    .sep { height: 12px; }
    .right { margin-left:auto; }
    details { border:1px solid var(--border); border-radius:12px; padding:10px 12px; background:var(--panel); }
    summary { font-weight:600; cursor:pointer; }
    .twocol { display:grid; grid-template-columns: repeat(auto-fill, minmax(260px,1fr)); gap:8px; }
    .smallinput { width:140px; }
    .inline { display:inline-flex; align-items:center; gap:8px; }
    .radio { display:inline-flex; align-items:center; gap:6px; margin-left: 8px; }
  </style>
</head>
<body>
  <header>
    <div class="wrap">
      <h1>ðŸ“Š EVM Block Profiler â€” Browser Runner</h1>
      <p class="small">Provider-aware rate limits + capped backoff & retries. ZIP export + dual-pass + logs-only.</p>
      <div class="toolbar">
        <div class="box row">
          <strong>RPC</strong>
          <input id="rpcInput" type="text" placeholder="https://mainnet.infura.io/v3/YOUR_KEY" />
          <button id="connectBtn" class="btn">Connect</button>
          <span id="rpcStatus" class="status"></span>
        </div>
        <div class="row box">
          <div>Provider</div>
          <select id="providerProfile">
            <option value="custom" selected>Custom</option>
            <option value="infura">Infura</option>
            <option value="alchemy">Alchemy</option>
            <option value="erigon">Erigon (self-hosted)</option>
            <option value="public">Public Node</option>
            <option value="local">Local (Geth/Nethermind)</option>
          </select>
          <div>Start</div><input id="startBlock" type="number" value="0" style="width:120px;">
          <div>End</div><input id="endBlock" type="number" value="0" style="width:120px;">
          <div>Page size</div><input id="pageSize" type="number" value="200" style="width:100px;">
          <div>Concurrency</div><input id="concurrency" type="number" value="8" style="width:90px;">
          <label><input id="skipContract" type="checkbox" checked> Skip contract check</label>
          <label class="inline"><input id="logsOnly" type="checkbox"> Logs-only</label>
          <label class="inline"><input id="dualPass" type="checkbox"> Dual-pass</label>
          <div>Tx cap</div><input id="txCap" type="number" value="" placeholder="optional" style="width:120px;">
          <div>Trace</div>
          <select id="traceMode">
            <option value="none" selected>none</option>
            <option value="erigon">erigon</option>
            <option value="geth">geth</option>
          </select>
          <button id="runBtn" class="btn primary">Run profiler</button>
        </div>
        <div class="row">
          <button id="exportJson" class="btn">Export summary.json</button>
          <button id="exportCsv" class="btn">Export per_block.csv</button>
          <button id="resolveTokens" class="btn">Resolve ERCâ€‘20 symbols</button>
          <div class="radio">
            <label><input type="radio" name="yamlMode" value="single" checked> Single YAML</label>
            <label><input type="radio" name="yamlMode" value="multiple"> Multiple files</label>
          </div>
          <button id="exportSpamoor" class="btn">Export Spamoor YAML</button>
          <button id="exportSpamoorZip" class="btn right">Download ZIP</button>
          <span id="runStatus" class="status"></span>
        </div>
        <div class="progress" style="flex:1; max-width: 650px;"><div id="progressbar"></div></div>
      </div>
    </div>
  </header>

  <main class="wrap">
    <section class="kpis" id="kpis"></section>
    <div class="sep"></div>

    <details>
      <summary>Spamoor export options & pinned scenarios</summary>
      <div class="twocol" style="margin-top:10px;">
        <label>Scenario name prefix <input id="spamoorName" class="smallinput" type="text" value="profiled" /></label>
        <label>Seed <input id="spamoorSeed" class="smallinput" type="text" value="evm-profiler" /></label>
        <label>Max wallets <input id="spamoorWallets" class="smallinput" type="number" value="200" /></label>
        <label>Max pending (Ã— throughput) <input id="spamoorPendingMult" class="smallinput" type="number" value="2" step="0.5" /></label>
        <label>Refill amount (wei) <input id="spamoorRefillAmount" class="smallinput" type="text" value="1000000000000000000" /></label>
        <label>Refill balance (wei) <input id="spamoorRefillBalance" class="smallinput" type="text" value="500000000000000000" /></label>
        <label>Refill interval (s) <input id="spamoorRefillInterval" class="smallinput" type="number" value="600" /></label>
        <label>Tip fee (gwei) default <input id="spamoorTip" class="smallinput" type="number" value="2" step="0.1" /></label>
        <label>ETH amount per tx (wei) <input id="spamoorEthAmount" class="smallinput" type="text" value="100000000000000" /></label>
      </div>
      <p class="small muted">Pinned scenarios: provide lines as <code>scenario_name weight</code>. Example: <code>uniswap-swaps 3</code></p>
      <textarea id="pinnedScenarios" placeholder="uniswap-swaps 3
storagespam 1
nft-mint 2"></textarea>
    </details>

    <section class="grid">
      <div class="panel">
        <h2>Transaction types</h2>
        <div class="flex">
          <div class="grow">
            <canvas id="txCountChart" height="240"></canvas>
          </div>
          <div class="grow">
            <canvas id="txShareChart" height="240"></canvas>
          </div>
        </div>
      </div>

      <div class="panel">
        <h2>By type (counts, gas, value)</h2>
        <div style="overflow:auto;">
          <table id="typesTable">
            <thead>
              <tr><th>Type</th><th>Count</th><th>Gas used</th><th>Avg gas price (gwei)</th><th>ETH value sum</th></tr>
            </thead>
            <tbody></tbody>
          </table>
        </div>
      </div>

      <div class="panel">
        <h2>Top contracts by tx count</h2>
        <div style="overflow:auto;">
          <table id="contractsTable">
            <thead>
              <tr><th>#</th><th>Contract</th><th>Tx count</th></tr>
            </thead>
            <tbody></tbody>
          </table>
        </div>
      </div>

      <div class="panel">
        <h2>Top tokens by events</h2>
        <div style="overflow:auto;">
          <table id="tokensTable">
            <thead>
              <tr><th>#</th><th>Token</th><th>Address</th><th>Events</th></tr>
            </thead>
            <tbody></tbody>
          </table>
        </div>
      </div>
    </section>
  </main>

  <script>
    const $ = (sel) => document.querySelector(sel);
    let web3 = null;
    let summary = null;
    let perBlockRows = [];
    let tokenMeta = {};

    const SIG_TRANSFER = Web3.utils.keccak256("Transfer(address,address,uint256)").toLowerCase();
    const SIG_ERC1155_SINGLE = Web3.utils.keccak256("TransferSingle(address,address,address,uint256,uint256)").toLowerCase();
    const SIG_ERC1155_BATCH = Web3.utils.keccak256("TransferBatch(address,address,address,uint256[],uint256[])").toLowerCase();
    const DEFAULT_TYPES = ["eth_transfer","contract_creation","erc20_transfer","erc721_transfer","erc1155_transfer","other_contract_call","mixed_token_activity","other_eoa_call"];
    const ERC20_ABI = [
      { "constant": true, "inputs": [], "name": "name", "outputs": [{"name":"","type":"string"}], "type": "function" },
      { "constant": true, "inputs": [], "name": "symbol", "outputs": [{"name":"","type":"string"}], "type": "function" },
      { "constant": true, "inputs": [], "name": "decimals", "outputs": [{"name":"","type":"uint8"}], "type": "function" },
    ];

    const rpcInput = $("#rpcInput");
    const connectBtn = $("#connectBtn");
    const rpcStatus = $("#rpcStatus");
    const providerProfile = $("#providerProfile");
    const startBlock = $("#startBlock");
    const endBlock = $("#endBlock");
    const pageSize = $("#pageSize");
    const concurrency = $("#concurrency");
    const skipContract = $("#skipContract");
    const logsOnly = $("#logsOnly");
    const dualPass = $("#dualPass");
    const txCap = $("#txCap");
    const traceMode = $("#traceMode");
    const runBtn = $("#runBtn");
    const runStatus = $("#runStatus");
    const progressbar = $("#progressbar");

    const spamoorName = $("#spamoorName");
    const spamoorSeed = $("#spamoorSeed");
    const spamoorWallets = $("#spamoorWallets");
    const spamoorPendingMult = $("#spamoorPendingMult");
    const spamoorRefillAmount = $("#spamoorRefillAmount");
    const spamoorRefillBalance = $("#spamoorRefillBalance");
    const spamoorRefillInterval = $("#spamoorRefillInterval");
    const spamoorTip = $("#spamoorTip");
    const spamoorEthAmount = $("#spamoorEthAmount");
    const pinnedScenarios = $("#pinnedScenarios");
    const exportSpamoor = $("#exportSpamoor");
    const exportSpamoorZip = $("#exportSpamoorZip");

    let txCountChart, txShareChart;

    function fmtNum(n) { if (n===null||n===undefined||Number.isNaN(n)) return "â€”"; return new Intl.NumberFormat(undefined,{maximumFractionDigits:6}).format(n); }
    function toHexTopic(x){ if (typeof x==="string") return x.toLowerCase(); try{ return Web3.utils.bytesToHex(x).toLowerCase(); }catch{ return String(x).toLowerCase(); } }
    function classifyFromLogs(logs){ let erc20=0,erc721=0,erc1155=0,dominant=null; const tokens={}; for(const lg of logs||[]){ if(!lg.topics||lg.topics.length===0) continue; const t0=toHexTopic(lg.topics[0]); const addr=(lg.address||"").toLowerCase(); if(t0===SIG_TRANSFER){ if (lg.data && lg.data!=="0x") erc20++; else erc721++; if(addr) tokens[addr]=(tokens[addr]||0)+1; } else if(t0===SIG_ERC1155_SINGLE||t0===SIG_ERC1155_BATCH){ erc1155++; if(addr) tokens[addr]=(tokens[addr]||0)+1; } } let maxC=0; for(const [a,c] of Object.entries(tokens)){ if(c>maxC){maxC=c; dominant=a;} } if (erc20>0&&erc721===0&&erc1155===0) return ["erc20_transfer",dominant]; if (erc721>0&&erc20===0&&erc1155===0) return ["erc721_transfer",dominant]; if (erc1155>0&&erc20===0&&erc721===0) return ["erc1155_transfer",dominant]; if (erc20||erc721||erc1155) return ["mixed_token_activity",dominant]; return ["other_contract_call",null]; }

    function resetUI(){ $("#kpis").innerHTML=""; $("#typesTable tbody").innerHTML=""; $("#contractsTable tbody").innerHTML=""; $("#tokensTable tbody").innerHTML=""; if (txCountChart){txCountChart.destroy(); txCountChart=null;} if (txShareChart){txShareChart.destroy(); txShareChart=null;} runStatus.textContent=""; progressbar.style.width="0%"; }

    function renderAll(){
      const d=summary, kpisEl=$("#kpis");
      const items=[["Blocks",d.block_count],["Total tx",d.total_tx],["Chain ID",d.chain_id],["ETH transferred",`${fmtNum(d.total_eth_transferred_eth)} ETH`],["Internal value",`${fmtNum(d.total_internal_value_eth)} ETH`],["Range",`${d.start_block} â€“ ${d.end_block}`]];
      kpisEl.innerHTML=items.map(([l,v])=>`<div class="kpi"><div class="label">${l}</div><div class="value">${v}</div></div>`).join("");

      const tbody=$("#typesTable tbody");
      const entries=Object.entries(d.tx_types||{}).sort((a,b)=>a[0].localeCompare(b[0]));
      tbody.innerHTML=entries.map(([t,v])=>`<tr><td><span class="pill">${t}</span></td><td>${fmtNum(v.count)}</td><td>${fmtNum(v.gas_used)}</td><td>${fmtNum(v.avg_gas_price_gwei)}</td><td>${fmtNum(v.eth_value_sum_eth)} ETH</td></tr>`).join("");

      const cBody=$("#contractsTable tbody");
      cBody.innerHTML=(d.top_contracts_by_tx||[]).map(([addr,n],i)=>`<tr><td>${i+1}</td><td><code>${addr}</code></td><td>${fmtNum(n)}</td></tr>`).join("");

      const tBody=$("#tokensTable tbody");
      tBody.innerHTML=(d.top_tokens_by_events||[]).map(([addr,n],i)=>`<tr><td>${i+1}</td><td>â€”</td><td><code>${addr}</code></td><td>${fmtNum(n)}</td></tr>`).join("");

      const ctx1=document.getElementById("txCountChart"), ctx2=document.getElementById("txShareChart");
      const labels=entries.map(([t])=>t);
      const counts=entries.map(([,v])=>v.count||0);
      const total=counts.reduce((a,b)=>a+b,0)||1;
      const shares=counts.map(c=>(c/total)*100);
      txCountChart=new Chart(ctx1,{type:"bar",data:{labels,datasets:[{label:"Tx count",data:counts}]},options:{responsive:true,plugins:{legend:{display:true},tooltip:{intersect:false}},scales:{y:{beginAtZero:true}}}});
      txShareChart=new Chart(ctx2,{type:"doughnut",data:{labels,datasets:[{label:"Share %",data:shares}]},options:{responsive:true,plugins:{legend:{position:"right"},tooltip:{callbacks:{label:(ctx)=>`${ctx.label}: ${fmtNum(ctx.parsed)}%`}}},cutout:"55%"}});
    }

    // Provider presets with RPS & backoff caps
    const presets = {
      custom: { rps: 8, maxRetries: 3, backoffBase: 250, backoffMaxMs: 4000 },
      infura:   { logsStep: 2000, page: 150, conc: 6, rps: 10, maxRetries: 5, backoffBase: 250, backoffMaxMs: 5000 },
      alchemy:  { logsStep: 2500, page: 180, conc: 8, rps: 12, maxRetries: 5, backoffBase: 200, backoffMaxMs: 4500 },
      erigon:   { logsStep: 6000, page: 400, conc: 12, rps: 30, maxRetries: 3, backoffBase: 100, backoffMaxMs: 2000 },
      public:   { logsStep: 1200, page: 120, conc: 4, rps: 4, maxRetries: 6, backoffBase: 400, backoffMaxMs: 8000 },
      local:    { logsStep: 8000, page: 500, conc: 16, rps: 40, maxRetries: 2, backoffBase: 80, backoffMaxMs: 1500 },
    };
    providerProfile.addEventListener("change", ()=>{
      const p = presets[providerProfile.value] || {};
      if (p.page) pageSize.value = p.page;
      if (p.conc) concurrency.value = p.conc;
    });

    // Simple rate limiter + retry/backoff
    class RateLimiter {
      constructor(rps){ this.minInterval = Math.max(1, Math.floor(1000 / Math.max(1, rps||8))); this.queue = []; this.active = false; this.last = 0; }
      schedule(fn){ return new Promise((resolve,reject)=>{ this.queue.push({fn,resolve,reject}); this.pump(); }); }
      pump(){ if (this.active) return; this.active = true; const step=()=>{ if (!this.queue.length){ this.active=false; return; } const now=Date.now(); const wait=Math.max(0, this.minInterval - (now - this.last)); setTimeout(()=>{ const item=this.queue.shift(); this.last=Date.now(); Promise.resolve().then(item.fn).then(item.resolve).catch(item.reject).finally(()=>step()); }, wait); }; step(); }
    }
    function jitter(ms){ return ms + Math.floor(Math.random()*Math.min(250, ms/2)); }
    async function withRetry(fn, {maxRetries=4, backoffBase=200, backoffMaxMs=5000}={}){
      let attempt=0; let lastErr=null;
      while (attempt<=maxRetries){
        try { return await fn(); } catch (e){ lastErr=e; const delay=Math.min(backoffMaxMs, Math.pow(2,attempt)*backoffBase); await new Promise(r=>setTimeout(r, jitter(delay))); attempt++; }
      }
      throw lastErr;
    }

    let limiter = new RateLimiter(presets.custom.rps);
    function updateLimiter(){ const p = presets[providerProfile.value] || presets.custom; limiter = new RateLimiter(p.rps || presets.custom.rps); }

    // Wrap web3 calls through limiter + retry
    function rpcCall(fn, args, opts={}){
      const p = presets[providerProfile.value] || presets.custom;
      return limiter.schedule(()=> withRetry(()=> fn(...args), {maxRetries: p.maxRetries, backoffBase: p.backoffBase, backoffMaxMs: p.backoffMaxMs}));
    }

    // RPC helpers
    async function connectRPC(){ const url=rpcInput.value.trim(); if(!url){ rpcStatus.textContent="Enter an RPC URL."; return false; } updateLimiter(); web3=new Web3(new Web3.providers.HttpProvider(url,{timeout:60000})); const ok=await withRetry(()=> web3.eth.net.isListening(), {maxRetries:2, backoffBase:200, backoffMaxMs:2000}).catch(()=>false); rpcStatus.textContent= ok ? "Connected" : "Failed to connect"; rpcStatus.style.color= ok ? "#22c55e" : "#ef4444"; return ok; }
    function updateProgress(cur,total){ const pct=Math.max(0,Math.min(100,Math.round((cur/Math.max(1,total))*100))); progressbar.style.width=pct+"%"; }

    // Logs scan
    async function scanLogsTokens(start, end, stepBlocks=2000) {
      const preset = presets[providerProfile.value] || {};
      const step = preset.logsStep || stepBlocks;
      const totalBlocks = end - start + 1;
      const ranges = [];
      for (let s=start; s<=end; s += step) {
        ranges.push([s, Math.min(end, s+step-1)]);
      }
      let c20=0, c721=0, c1155=0;
      const tokenTxHashes = new Set();
      for (let i=0; i<ranges.length; i++) {
        const [a,b] = ranges[i];
        try {
          const logs = await rpcCall(web3.eth.getPastLogs, [{ fromBlock: a, toBlock: b, topics: [SIG_TRANSFER] }]);
          for (const lg of logs) {
            if (lg.transactionHash) tokenTxHashes.add(lg.transactionHash.toLowerCase());
            if (lg.data && lg.data !== "0x") c20++; else c721++;
          }
        } catch {}
        try {
          const l1 = await rpcCall(web3.eth.getPastLogs, [{ fromBlock: a, toBlock: b, topics: [SIG_ERC1155_SINGLE] }]);
          const l2 = await rpcCall(web3.eth.getPastLogs, [{ fromBlock: a, toBlock: b, topics: [SIG_ERC1155_BATCH] }]);
          for (const lg of (l1||[])) if (lg.transactionHash) tokenTxHashes.add(lg.transactionHash.toLowerCase());
          for (const lg of (l2||[])) if (lg.transactionHash) tokenTxHashes.add(lg.transactionHash.toLowerCase());
          c1155 += (l1?.length||0) + (l2?.length||0);
        } catch {}
        updateProgress(Math.min(end, b) - start + 1, totalBlocks);
      }
      return {erc20:c20, erc721:c721, erc1155:c1155, tokenTxHashes};
    }

    async function runProfiler(){
      resetUI(); runStatus.textContent="Connecting..."; const ok=await connectRPC(); if(!ok){return;}
      const start=Number(startBlock.value), end=Number(endBlock.value), page=Math.max(1,Number(pageSize.value)), conc=Math.max(1,Number(concurrency.value)); const doSkip=!!skipContract.checked; const txCapN=Number(txCap.value||"0")||null; const trace=traceMode.value;
      if(!Number.isFinite(start)||!Number.isFinite(end)||end<start){ runStatus.textContent="Invalid range"; return; }

      // Pass 1: logs scan if requested
      let tokenHashSet = null, logsPassStats = null;
      if (logsOnly.checked || dualPass.checked) {
        runStatus.textContent = "Pass 1: scanning logs for token activityâ€¦";
        const tokens = await scanLogsTokens(start, end, Math.max(500, page*10));
        logsPassStats = tokens;
        tokenHashSet = tokens.tokenTxHashes;
        if (logsOnly.checked && !dualPass.checked) {
          const totalTok = tokens.erc20 + tokens.erc721 + tokens.erc1155;
          summary = {
            start_block:start, end_block:end, chain_id:Number(await withRetry(()=> web3.eth.getChainId())), block_count:end-start+1,
            total_tx: totalTok,
            unique_senders:-1, unique_receivers:-1, total_eth_transferred_eth: 0, total_internal_value_eth: 0,
            tx_types: {
              contract_creation:{count:0,gas_used:0,avg_gas_price_gwei:0,eth_value_sum_eth:0},
              erc20_transfer:{count:tokens.erc20,gas_used:0,avg_gas_price_gwei:0,eth_value_sum_eth:0},
              erc721_transfer:{count:tokens.erc721,gas_used:0,avg_gas_price_gwei:0,eth_value_sum_eth:0},
              erc1155_transfer:{count:tokens.erc1155,gas_used:0,avg_gas_price_gwei:0,eth_value_sum_eth:0},
              other_contract_call:{count:0,gas_used:0,avg_gas_price_gwei:0,eth_value_sum_eth:0},
              mixed_token_activity:{count:0,gas_used:0,avg_gas_price_gwei:0,eth_value_sum_eth:0},
              eth_transfer:{count:0,gas_used:0,avg_gas_price_gwei:0,eth_value_sum_eth:0},
              other_eoa_call:{count:0,gas_used:0,avg_gas_price_gwei:0,eth_value_sum_eth:0}
            },
            top_contracts_by_tx: [], top_tokens_by_events: []
          };
          renderAll(); runStatus.textContent = "Logs scan complete"; updateProgress(1,1);
          return;
        }
      }

      // Pass 2: selective receipts or full
      runStatus.textContent = dualPass.checked ? "Pass 2: selective receiptsâ€¦" : "Runningâ€¦";
      perBlockRows=[]; let totalTx=0; let totalEth=0n; let internalWei=0n; const txTypeStats={}; const topContracts={}; const topTokens={}; const codeCache={};
      const countType=(type)=> txTypeStats[type] || (txTypeStats[type]={count:0,gas_used:0,gas_price_wei_sum:0n,eth_value_wei_sum:0n});
      const classifyTx=(tx,rc)=>{ if(!tx.to) return ["contract_creation",null]; const [typ, tok]=classifyFromLogs(rc?.logs||[]); if(typ==="other_contract_call"){ if(BigInt(tx.value||0)>0n) return ["eth_transfer",null]; if(!doSkip){ const a=tx.to.toLowerCase(); return [codeCache[a]?"other_contract_call":"other_eoa_call",null]; } } return [typ,tok]; };
      const toEth=(w)=>Number(Web3.utils.fromWei(String(w),"ether"));
      const blocksTotal=end-start+1;

      for(let cur=start; cur<=end; cur+=page){
        const chunkEnd=Math.min(end,cur+page-1);
        const blockNums=[]; for(let b=cur;b<=chunkEnd;b++) blockNums.push(b);
        const blocks = await Promise.all(blockNums.map(b => rpcCall(web3.eth.getBlock, [b, true]).catch(()=>null)));
        if(!doSkip){
          const addrs=[]; for(const blk of blocks){ if(!blk) continue; for(const tx of (blk.transactions||[])){ if(tx.to){ const a=tx.to.toLowerCase(); if(codeCache[a]===undefined) addrs.push(a); } } }
          const uniq=[...new Set(addrs)]; await Promise.all(uniq.map(a=> rpcCall(web3.eth.getCode, [a]).then(c=>{ codeCache[a]=!!(c&&c!=="0x"&&c!=="0x00");}).catch(()=>{codeCache[a]=true;})));
        }
        for(const blk of blocks){
          if(!blk) continue;
          const txs=blk.transactions||[];

          let receipts = new Array(txs.length).fill(null);
          if (dualPass.checked && tokenHashSet) {
            await Promise.all(txs.map(async (tx, i) => {
              const isToken = tokenHashSet.has((tx.hash||"").toLowerCase());
              if (!isToken) {
                try { receipts[i] = await rpcCall(web3.eth.getTransactionReceipt, [tx.hash]); } catch {}
              }
            }));
          } else {
            receipts = await Promise.all(txs.map(tx=> rpcCall(web3.eth.getTransactionReceipt, [tx.hash]).catch(()=>null)));
          }

          let blockCounts={}; let blockGasUsed=0n;
          for(let i=0;i<txs.length;i++){
            const tx=txs[i]; let rc=receipts[i];
            if (!rc && dualPass.checked && tokenHashSet && tokenHashSet.has((tx.hash||"").toLowerCase())) {
              rc = { logs: [{ topics: [SIG_TRANSFER], data: tx.input && tx.input !== "0x" ? "0x01" : "0x" }], gasUsed: 0 };
            }
            if(!rc) continue;
            totalTx+=1; const gasUsed=BigInt(rc.gasUsed||0); blockGasUsed+=gasUsed; const gasPrice=BigInt(tx.gasPrice||0); const value=BigInt(tx.value||0);
            const [typ, tokenAddr]=classifyTx(tx,rc);
            const s=countType(typ); s.count+=1; s.gas_used+=Number(gasUsed); s.gas_price_wei_sum+=gasPrice; s.eth_value_wei_sum+=value;
            blockCounts[typ]=(blockCounts[typ]||0)+1; totalEth+=value;
            if(tx.to){ const lc=tx.to.toLowerCase(); topContracts[lc]=(topContracts[lc]||0)+1; }
            if(tokenAddr){ const lc=tokenAddr.toLowerCase(); topTokens[lc]=(topTokens[lc]||0)+1; }
            if(txCapN && totalTx>=txCapN) break;
          }
          perBlockRows.push([blk.number, blk.timestamp, txs.length, DEFAULT_TYPES.map(t=>blockCounts[t]||0).join("|"), Number(blockGasUsed), Number(blk.gasLimit||0)]);
          if(txCapN && totalTx>=txCapN) break;
        }
        updateProgress(chunkEnd-start+1, blocksTotal);
        if(txCapN && totalTx>=txCapN) break;
      }
      const tx_types={};
      for(const [k,v] of Object.entries(txTypeStats)){
        const avgGwei=v.count ? Number(v.gas_price_wei_sum)/v.count/1e9 : 0;
        tx_types[k]={ count:v.count, gas_used:v.gas_used, avg_gas_price_gwei: Math.round(avgGwei*10000)/10000, eth_value_sum_eth: toEth(v.eth_value_wei_sum) };
      }
      const topContractsSorted=Object.entries(topContracts).sort((a,b)=>b[1]-a[1]).slice(0,20);
      const topTokensSorted=Object.entries(topTokens).sort((a,b)=>b[1]-a[1]).slice(0,20);
      summary={ start_block:start, end_block:end, chain_id:Number(await withRetry(()=> web3.eth.getChainId())), block_count:end-start+1, total_tx: totalTx, unique_senders:-1, unique_receivers:-1, total_eth_transferred_eth: toEth(totalEth), total_internal_value_eth: 0, tx_types, top_contracts_by_tx: topContractsSorted, top_tokens_by_events: topTokensSorted, notes: dualPass.checked ? ["Dual-pass: logs-first, selective receipts; token gas used may be 0 if skipped."] : [] };
      renderAll(); runStatus.textContent= dualPass.checked ? "Dual-pass complete" : "Done"; updateProgress(1,1);
    }

    connectBtn.addEventListener("click", connectRPC);
    runBtn.addEventListener("click", runProfiler);

    function dl(name, text, mime="application/octet-stream"){ const a=document.createElement("a"); a.href=URL.createObjectURL(new Blob([text],{type:mime})); a.download=name; document.body.appendChild(a); a.click(); a.remove(); }
    $("#exportJson").addEventListener("click", ()=>{ if(!summary){ runStatus.textContent="Nothing to export yet."; return; } dl("summary.json", JSON.stringify(summary,null,2), "application/json"); });
    $("#exportCsv").addEventListener("click", ()=>{
      if(!perBlockRows.length){ runStatus.textContent="No per-block data yet."; return; }
      const header=["block_number","timestamp","tx_count","eth_transfer","contract_creation","erc20_transfer","erc721_transfer","erc1155_transfer","other_contract_call","mixed_token_activity","other_eoa_call","block_gas_used","block_gas_limit"];
      const lines=[header.join(",")].concat(perBlockRows.map(r=>r.join(",")));
      dl("per_block.csv", lines.join("\n"), "text/csv");
    });

    function inferBaseFeeFromAvg(avgGwei, tipDefault){ const base = Math.max((avgGwei||0) - (tipDefault||2), 1); return Math.round(base*10)/10; }
    function estimateSlots(){ if (perBlockRows.length>=2){ const first=perBlockRows[0][1]; const last=perBlockRows[perBlockRows.length-1][1]; const dur = Math.max(1, (last-first)); return Math.max(1, Math.round(dur/12)); } const blocks = (summary?.block_count)||1; return Math.max(1, Math.round(blocks)); }
    function mapTypeToScenario(type){ if (type==="eth_transfer") return "eoatx"; if (type==="erc20_transfer") return "erctx"; if (type==="contract_creation") return "deploytx"; return "calltx"; }

    function parsePinnedScenarios(text){
      const lines = (text||"").split(/\r?\n/).map(s=>s.trim()).filter(Boolean);
      const arr = [];
      for (const line of lines) {
        const m = line.match(/^([A-Za-z0-9_\-]+)\s+([0-9]*\.?[0-9]+)$/);
        if (m) arr.push({name: m[1], weight: parseFloat(m[2])});
      }
      return arr;
    }

    function buildScenarioObjects(){
      const tip = Number(spamoorTip.value||"2");
      const namePrefix = spamoorName.value || "profiled";
      const seed = spamoorSeed.value || "evm-profiler";
      const maxWallets = Number(spamoorWallets.value||"200");
      const pendingMult = Number(spamoorPendingMult.value||"2");
      const refillAmount = spamoorRefillAmount.value || "1000000000000000000";
      const refillBalance = spamoorRefillBalance.value || "500000000000000000";
      const refillInterval = Number(spamoorRefillInterval.value||"600");
      const ethAmount = spamoorEthAmount.value || "100000000000000";

      const types = Object.entries(summary.tx_types||{});
      const totalCount = types.reduce((a,[,v])=> a + (v.count||0), 0) || 1;
      const slots = estimateSlots();
      const agg = {};
      for (const [t, v] of types){
        const scenario = mapTypeToScenario(t);
        const share = (v.count||0) / totalCount;
        const throughput = Math.max(0, Math.round((summary.total_tx||0) * share / slots)); // tx per slot
        const base = inferBaseFeeFromAvg(v.avg_gas_price_gwei||0, tip);
        if (!agg[scenario]) agg[scenario] = { count:0, throughput:0, base_gwei:0, types:[] };
        agg[scenario].count += (v.count||0);
        agg[scenario].throughput += throughput;
        agg[scenario].base_gwei = Math.max(agg[scenario].base_gwei, base);
        agg[scenario].types.push({ type: t, share: Math.round(share*1000)/10, avg_gwei: v.avg_gas_price_gwei||0 });
      }

      const scenarios = [];
      for (const [scenario, info] of Object.entries(agg)){
        if (scenario === "calltx") continue;
        scenarios.push({
          scenario,
          name: `${namePrefix}-${scenario}`,
          description: `Auto-generated from EVM Profiler. Types: ${info.types.map(x=>x.type).join(", ")}`,
          config: {
            seed, refill_amount: refillAmount, refill_balance: refillBalance, refill_interval: refillInterval,
            throughput: Math.round(info.throughput), max_pending: Math.max(1, Math.round((info.throughput||0) * pendingMult)),
            max_wallets: maxWallets, base_fee: info.base_gwei || 1, tip_fee: tip,
            ...(scenario==="eoatx" ? { amount: ethAmount } : {})
          }
        });
      }

      const pinned = parsePinnedScenarios(pinnedScenarios.value);
      const callAgg = agg["calltx"];
      if (callAgg && pinned.length){
        const totalW = pinned.reduce((a,p)=>a+p.weight,0) || 1;
        for (const p of pinned){
          scenarios.push({
            scenario: p.name,
            name: `${namePrefix}-${p.name}`,
            description: `Auto-generated from EVM Profiler. Sourced from calltx cohort: ${callAgg.types.map(x=>x.type).join(", ")}`,
            config: {
              seed, refill_amount: refillAmount, refill_balance: refillBalance, refill_interval: refillInterval,
              throughput: Math.round((callAgg.throughput||0) * (p.weight/totalW)),
              max_pending: Math.max(1, Math.round(((callAgg.throughput||0) * (p.weight/totalW)) * pendingMult)),
              max_wallets: maxWallets, base_fee: callAgg.base_gwei || 1, tip_fee: tip
            }
          });
        }
      } else if (callAgg) {
        scenarios.push({
          scenario: "calltx",
          name: `${namePrefix}-calltx`,
          description: `Auto-generated from EVM Profiler. Types: ${callAgg.types.map(x=>x.type).join(", ")}`,
          config: {
            seed, refill_amount: refillAmount, refill_balance: refillBalance, refill_interval: refillInterval,
            throughput: Math.round(callAgg.throughput),
            max_pending: Math.max(1, Math.round((callAgg.throughput||0) * pendingMult)),
            max_wallets: maxWallets, base_fee: callAgg.base_gwei || 1, tip_fee: tip
          }
        });
      }

      return scenarios;
    }

    function toYaml(obj){
      const L = [];
      L.push(`- scenario: ${obj.scenario}`);
      L.push(`  name: "${obj.name}"`);
      L.push(`  description: "${obj.description.replace(/"/g,'\\"')}"`);
      L.push(`  config:`);
      const cfg = obj.config || {};
      for (const [k,v] of Object.entries(cfg)) {
        L.push(`    ${k}: ${v}`);
      }
      return L.join("\n");
    }

    exportSpamoor.addEventListener("click", ()=>{
      if (!summary) { runStatus.textContent = "Run profiler first."; return; }
      const scenarios = buildScenarioObjects();
      const mode = document.querySelector('input[name="yamlMode"]:checked').value;
      if (mode === "single") {
        const yaml = scenarios.map(toYaml).join("\n\n");
        dl("spamoor_scenarios.yaml", yaml, "text/yaml");
      } else {
        for (const sc of scenarios) {
          const yaml = toYaml(sc);
          const fname = `spamoor_${sc.scenario}.yaml`;
          dl(fname, yaml, "text/yaml");
        }
      }
    });

    // Minimal ZIP (store) builder for multiple YAMLs
    function strToUint8(s){ const enc = new TextEncoder(); return enc.encode(s); }
    function numToBytesLE(n, len){ const a=new Uint8Array(len); for(let i=0;i<len;i++){ a[i]=n & 0xff; n>>=8; } return a; }
    function crc32(buf){
      let c = ~0;
      for (let i=0;i<buf.length;i++){
        c ^= buf[i];
        for (let k=0;k<8;k++){ c = (c>>>1) ^ (0xEDB88320 & (~(c&1)+1)); }
      }
      return ~c >>> 0;
    }
    function makeZip(files){
      const LFH_SIG = 0x04034b50, CD_SIG = 0x02014b50, EOCD_SIG=0x06054b50;
      let chunks = [];
      let central = [];
      let offset = 0;
      for (const f of files){
        const nameBytes = strToUint8(f.name);
        const data = f.data;
        const crc = crc32(data);
        const lfh = new Uint8Array(30 + nameBytes.length);
        let p=0;
        lfh.set(numToBytesLE(LFH_SIG,4), p); p+=4;
        lfh.set(numToBytesLE(20,2), p); p+=2;
        lfh.set(numToBytesLE(0,2), p); p+=2;
        lfh.set(numToBytesLE(0,2), p); p+=2;
        lfh.set(numToBytesLE(0,2), p); p+=2;
        lfh.set(numToBytesLE(0,2), p); p+=2;
        lfh.set(numToBytesLE(crc,4), p); p+=4;
        lfh.set(numToBytesLE(data.length,4), p); p+=4;
        lfh.set(numToBytesLE(data.length,4), p); p+=4;
        lfh.set(numToBytesLE(nameBytes.length,2), p); p+=2;
        lfh.set(numToBytesLE(0,2), p); p+=2;
        lfh.set(nameBytes, p); p+=nameBytes.length;
        chunks.push(lfh, data);
        const cdh = new Uint8Array(46 + nameBytes.length);
        p=0;
        cdh.set(numToBytesLE(CD_SIG,4), p); p+=4;
        cdh.set(numToBytesLE(20,2), p); p+=2;
        cdh.set(numToBytesLE(20,2), p); p+=2;
        cdh.set(numToBytesLE(0,2), p); p+=2;
        cdh.set(numToBytesLE(0,2), p); p+=2;
        cdh.set(numToBytesLE(0,2), p); p+=2;
        cdh.set(numToBytesLE(0,2), p); p+=2;
        cdh.set(numToBytesLE(crc,4), p); p+=4;
        cdh.set(numToBytesLE(data.length,4), p); p+=4;
        cdh.set(numToBytesLE(data.length,4), p); p+=4;
        cdh.set(numToBytesLE(nameBytes.length,2), p); p+=2;
        cdh.set(numToBytesLE(0,2), p); p+=2;
        cdh.set(numToBytesLE(0,2), p); p+=2;
        cdh.set(numToBytesLE(0,2), p); p+=2;
        cdh.set(numToBytesLE(0,2), p); p+=2;
        cdh.set(numToBytesLE(offset,4), p); p+=4;
        cdh.set(nameBytes, p); p+=nameBytes.length;
        central.push({buf: cdh});
        offset += lfh.length + data.length;
      }
      const centralBlob = central.reduce((acc, x)=>{
        const n = new Uint8Array(acc.length + x.buf.length);
        n.set(acc,0); n.set(x.buf, acc.length); return n;
      }, new Uint8Array(0));
      const eocd = new Uint8Array(22);
      let p=0;
      eocd.set(numToBytesLE(EOCD_SIG,4), p); p+=4;
      eocd.set(numToBytesLE(0,2), p); p+=2;
      eocd.set(numToBytesLE(0,2), p); p+=2;
      const entries = central.length;
      eocd.set(numToBytesLE(entries,2), p); p+=2;
      eocd.set(numToBytesLE(entries,2), p); p+=2;
      eocd.set(numToBytesLE(centralBlob.length,4), p); p+=4;
      const centralOffset = offset;
      eocd.set(numToBytesLE(centralOffset,4), p); p+=4;
      eocd.set(numToBytesLE(0,2), p); p+=2;
      let totalLen = offset + centralBlob.length + eocd.length;
      const out = new Uint8Array(totalLen);
      let w=0;
      for (const c of chunks) { out.set(c, w); w += c.length; }
      out.set(centralBlob, w); w += centralBlob.length;
      out.set(eocd, w);
      return new Blob([out], {type: "application/zip"});
    }

    exportSpamoorZip.addEventListener("click", ()=>{
      if (!summary) { runStatus.textContent = "Run profiler first."; return; }
      const scenarios = buildScenarioObjects();
      const files = scenarios.map(sc => ({
        name: `spamoor_${sc.scenario}.yaml`,
        data: (new TextEncoder()).encode(toYaml(sc))
      }));
      const zip = makeZip(files);
      const a = document.createElement("a");
      a.href = URL.createObjectURL(zip);
      a.download = "spamoor_scenarios.zip";
      document.body.appendChild(a); a.click(); a.remove();
    });

    // Resolve ERC-20 symbols (optional utility)
    $("#resolveTokens").addEventListener("click", async ()=>{
      if (!summary) { runStatus.textContent="Run profiler or load a summary first."; return; }
      if (!web3) { runStatus.textContent="Connect an RPC first."; return; }
      const addrs=(summary.top_tokens_by_events||[]).map(([a])=>a);
      const out={};
      for (const a of addrs){
        try { const c=new web3.eth.Contract(ERC20_ABI,a); const [name,symbol,decimals]=await Promise.all([c.methods.name().call(),c.methods.symbol().call(),c.methods.decimals().call()]); out[a.toLowerCase()]={name,symbol,decimals:Number(decimals)}; } catch { out[a.toLowerCase()]={name:"Unknown",symbol:"?",decimals:null}; }
      }
      tokenMeta=out;
      const tBody=$("#tokensTable tbody");
      tBody.innerHTML=(summary.top_tokens_by_events||[]).map(([addr,n],i)=>{
        const meta=tokenMeta[addr?.toLowerCase()]; const label=meta?`${meta.symbol||"?"} (${meta.name||"?"}${meta.decimals!=null?`, ${meta.decimals}`:""})`:"â€”";
        return `<tr><td>${i+1}</td><td>${label}</td><td><code>${addr}</code></td><td>${fmtNum(n)}</td></tr>`;
      }).join("");
    });
  </script>
</body>
</html>
