<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>EVM Block Profiler â€“ Browser Runner (merged + faster)</title>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap" rel="stylesheet">
  <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.1/dist/chart.umd.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/web3@1.10.4/dist/web3.min.js"></script>
  <style>
    :root {
      --bg: #0f1115;
      --panel: #171a21;
      --muted: #9aa4b2;
      --fg: #e5e7eb;
      --accent: #4f46e5;
      --accent2: #22c55e;
      --card: #1f2430;
      --border: #2b3240;
    }
    * { box-sizing: border-box; }
    body {
      margin: 0;
      padding: 0 16px 60px;
      font-family: "Inter", system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
      background: linear-gradient(180deg, #0f1115, #0b0d11);
      color: var(--fg);
    }
    header {
      position: sticky;
      top: 0;
      background: rgba(15,17,21,0.8);
      -webkit-backdrop-filter: blur(10px);
      backdrop-filter: blur(10px);
      z-index: 10;
      padding: 14px 0 10px;
    }
    .wrap { max-width: 1200px; margin: 0 auto; }
    h1 { margin: 8px 0 0; font-size: 22px; font-weight: 700; letter-spacing: .2px; }
    p.small { color: var(--muted); margin: 6px 0 0; font-size: 13px; }
    .toolbar, .row { display:flex; gap:10px; align-items:center; flex-wrap: wrap; }
    .toolbar { margin:14px 0 0; }
    .box {
      display:flex; align-items:center; gap:8px; padding:10px 12px; border:1px solid var(--border);
      border-radius:10px; background: var(--panel);
    }
    input[type="text"], input[type="number"], select {
      padding:8px 10px; border-radius:8px; border:1px solid var(--border);
      background: #0c0f14; color: var(--fg);
    }
    input[type="text"] { width: 520px; max-width: 70vw; }
    .btn {
      border:1px solid var(--border); background: var(--panel); color: var(--fg);
      padding:10px 12px; border-radius:10px; cursor:pointer;
    }
    .btn.primary { background: var(--accent); border-color: #3f3ab6; }
    .btn.ghost { background: transparent; }
    .status { color: var(--muted); font-size: 12px; }
    .grid { display:grid; grid-template-columns: 1fr; gap:16px; margin-top:18px; }
    .panel { background: var(--card); border:1px solid var(--border); border-radius:14px; padding:16px; }
    .panel h2 { margin:0 0 10px; font-size:18px; }
    .kpis { display:grid; grid-template-columns: repeat(auto-fill, minmax(200px,1fr)); gap:12px; margin-top:12px; }
    .kpi { background: var(--card); border:1px solid var(--border); border-radius:14px; padding:14px; }
    .kpi .label { color: var(--muted); font-size:12px; }
    .kpi .value { font-size:22px; font-weight:700; margin-top:4px; }
    .flex { display:flex; gap:16px; flex-wrap: wrap; }
    .grow { flex:1; min-width: 320px; }
    table { width:100%; border-collapse: collapse; }
    th, td { padding:10px; border-bottom:1px solid var(--border); font-size: 13px; }
    th { text-align:left; color: var(--muted); font-weight:600; }
    tr:hover { background: rgba(255,255,255,0.03); }
    .pill { display:inline-block; padding:3px 8px; border-radius:999px; background: #0e7490; font-size:12px; }
    .muted { color: var(--muted); }
    .progress { height: 10px; background: #0c0f14; border:1px solid var(--border); border-radius: 8px; overflow: hidden; }
    .progress > div { height: 100%; background: var(--accent); width: 0%; }
    .footer-note { color: var(--muted); margin-top:16px; font-size:12px; }
    code { background: #0c0f14; border:1px solid var(--border); padding: 2px 6px; border-radius: 6px; }
    .sep { height: 12px; }
  </style>
</head>
<body>
  <header>
    <div class="wrap">
      <h1>ðŸ“Š EVM Block Profiler â€” Browser Runner</h1>
      <p class="small">
        Enter your RPC + range and run a <strong>lite</strong> profiler in the browser. 
        You can also <strong>merge</strong> another <code>summary.json</code>. Adaptive concurrency + backoff reduce rate-limit errors.
      </p>
      <div class="toolbar">
        <div class="box row">
          <strong>RPC</strong>
          <input id="rpcInput" type="text" placeholder="https://mainnet.infura.io/v3/YOUR_KEY" />
          <button id="connectBtn" class="btn">Connect</button>
          <span id="rpcStatus" class="status"></span>
        </div>
        <div class="row box">
          <div>Start</div><input id="startBlock" type="number" value="0" style="width:120px;">
          <div>End</div><input id="endBlock" type="number" value="0" style="width:120px;">
          <div>Page size</div><input id="pageSize" type="number" value="200" style="width:100px;">
          <div>Concurrency</div><input id="concurrency" type="number" value="8" style="width:90px;">
          <label><input id="skipContract" type="checkbox" checked> Skip contract check</label>
          <label><input id="enableBatch" type="checkbox"> Try JSON-RPC batch</label>
          <div>Tx cap</div><input id="txCap" type="number" value="" placeholder="optional" style="width:120px;">
          <div>Trace</div>
          <select id="traceMode">
            <option value="none" selected>none</option>
            <option value="erigon">erigon (may be blocked)</option>
            <option value="geth">geth (heavy / often blocked)</option>
          </select>
          <button id="runBtn" class="btn primary">Run profiler</button>
          <button id="resumeBtn" class="btn">Resume</button>
        </div>
        <div class="row">
          <button id="exportJson" class="btn">Export summary.json</button>
          <button id="exportCsv" class="btn">Export per_block.csv</button>
          <button id="resolveTokens" class="btn">Resolve ERCâ€‘20 symbols</button>
          <label class="box"><strong>Merge </strong> <input id="mergeInput" type="file" accept="application/json,.json" /></label>
          <span id="runStatus" class="status"></span>
        </div>
        <div class="progress" style="flex:1; max-width: 650px;"><div id="progressbar"></div></div>
      </div>
    </div>
  </header>

  <main class="wrap">
    <section class="kpis" id="kpis"></section>
    <div class="sep"></div>
    <section class="grid">
      <div class="panel">
        <h2>Transaction types</h2>
        <div class="flex">
          <div class="grow">
            <canvas id="txCountChart" height="240"></canvas>
          </div>
          <div class="grow">
            <canvas id="txShareChart" height="240"></canvas>
          </div>
        </div>
      </div>

      <div class="panel">
        <h2>By type (counts, gas, value)</h2>
        <div style="overflow:auto;">
          <table id="typesTable">
            <thead>
              <tr>
                <th>Type</th>
                <th>Count</th>
                <th>Gas used</th>
                <th>Avg gas price (gwei)</th>
                <th>ETH value sum</th>
              </tr>
            </thead>
            <tbody></tbody>
          </table>
        </div>
      </div>

      <div class="panel">
        <h2>Top contracts by tx count</h2>
        <div style="overflow:auto;">
          <table id="contractsTable">
            <thead>
              <tr><th>#</th><th>Contract</th><th>Tx count</th></tr>
            </thead>
            <tbody></tbody>
          </table>
        </div>
      </div>

      <div class="panel">
        <h2>Top tokens by events <span id="tokenSubtitle" class="muted"></span></h2>
        <div style="overflow:auto;">
          <table id="tokensTable">
            <thead>
              <tr><th>#</th><th>Token</th><th>Address</th><th>Events</th></tr>
            </thead>
            <tbody></tbody>
          </table>
        </div>
        <p class="footer-note">Token metadata is fetched via your RPC from <code>name()</code>, <code>symbol()</code>, and <code>decimals()</code>.</p>
      </div>
    </section>
  </main>

  <script>
    const $ = (sel) => document.querySelector(sel);
    let web3 = null;
    let summary = null;
    let perBlockRows = []; // [block, ts, txCount, countsString, gasUsed, gasLimit]
    let tokenMeta = {};

    // Adaptive concurrency
    let targetConcurrency = 8;
    let recentErrors = 0;
    let recentCalls = 0;

    const SIG_TRANSFER = Web3.utils.keccak256("Transfer(address,address,uint256)").toLowerCase();
    const SIG_ERC1155_SINGLE = Web3.utils.keccak256("TransferSingle(address,address,address,uint256,uint256)").toLowerCase();
    const SIG_ERC1155_BATCH = Web3.utils.keccak256("TransferBatch(address,address,address,uint256[],uint256[])").toLowerCase();
    const DEFAULT_TYPES = ["eth_transfer","contract_creation","erc20_transfer","erc721_transfer","erc1155_transfer","other_contract_call","mixed_token_activity","other_eoa_call"];
    const ERC20_ABI = [
      { "constant": true, "inputs": [], "name": "name", "outputs": [{"name":"","type":"string"}], "type": "function" },
      { "constant": true, "inputs": [], "name": "symbol", "outputs": [{"name":"","type":"string"}], "type": "function" },
      { "constant": true, "inputs": [], "name": "decimals", "outputs": [{"name":"","type":"uint8"}], "type": "function" },
    ];

    const rpcInput = $("#rpcInput");
    const connectBtn = $("#connectBtn");
    const rpcStatus = $("#rpcStatus");
    const startBlock = $("#startBlock");
    const endBlock = $("#endBlock");
    const pageSize = $("#pageSize");
    const concurrency = $("#concurrency");
    const skipContract = $("#skipContract");
    const txCap = $("#txCap");
    const traceMode = $("#traceMode");
    const enableBatch = $("#enableBatch");
    const runBtn = $("#runBtn");
    const resumeBtn = $("#resumeBtn");
    const runStatus = $("#runStatus");
    const progressbar = $("#progressbar");
    const tokenSubtitle = $("#tokenSubtitle");
    const mergeInput = $("#mergeInput");

    let txCountChart, txShareChart;

    // Save/restore resume state in localStorage
    function saveState(state) { localStorage.setItem("evm_profiler_state", JSON.stringify(state)); }
    function loadState() { try { return JSON.parse(localStorage.getItem("evm_profiler_state") || "null"); } catch { return null; } }
    function clearState() { localStorage.removeItem("evm_profiler_state"); }

    function fmtNum(n) {
      if (n === null || n === undefined || Number.isNaN(n)) return "â€”";
      return new Intl.NumberFormat(undefined, { maximumFractionDigits: 6 }).format(n);
    }
    function toHexTopic(x) {
      if (typeof x === "string") return x.toLowerCase();
      try { return Web3.utils.bytesToHex(x).toLowerCase(); } catch { return String(x).toLowerCase(); }
    }
    function classifyFromLogs(logs) {
      let erc20 = 0, erc721 = 0, erc1155 = 0, dominantAddr = null;
      const tokens = {};
      for (const lg of logs || []) {
        if (!lg.topics || lg.topics.length === 0) continue;
        const topic0 = toHexTopic(lg.topics[0]);
        const addr = (lg.address || "").toLowerCase();
        if (topic0 === SIG_TRANSFER) {
          if (lg.data && lg.data !== "0x") erc20 += 1; else erc721 += 1;
          if (addr) tokens[addr] = (tokens[addr] || 0) + 1;
        } else if (topic0 === SIG_ERC1155_SINGLE || topic0 === SIG_ERC1155_BATCH) {
          erc1155 += 1;
          if (addr) tokens[addr] = (tokens[addr] || 0) + 1;
        }
      }
      let maxC = 0;
      for (const [a,c] of Object.entries(tokens)) { if (c>maxC) { maxC=c; dominantAddr=a; } }
      if (erc20 > 0 && erc721 === 0 && erc1155 === 0) return ["erc20_transfer", dominantAddr];
      if (erc721 > 0 && erc20 === 0 && erc1155 === 0) return ["erc721_transfer", dominantAddr];
      if (erc1155 > 0 && erc20 === 0 && erc721 === 0) return ["erc1155_transfer", dominantAddr];
      if (erc20 || erc721 || erc1155) return ["mixed_token_activity", dominantAddr];
      return ["other_contract_call", null];
    }

    function resetUI() {
      $("#kpis").innerHTML = "";
      $("#typesTable tbody").innerHTML = "";
      $("#contractsTable tbody").innerHTML = "";
      $("#tokensTable tbody").innerHTML = "";
      if (txCountChart) { txCountChart.destroy(); txCountChart = null; }
      if (txShareChart) { txShareChart.destroy(); txShareChart = null; }
      tokenSubtitle.textContent = "";
      runStatus.textContent = "";
      progressbar.style.width = "0%";
    }

    function renderAll() {
      const d = summary;
      const kpisEl = $("#kpis");
      const items = [
        ["Blocks", d.block_count],
        ["Total tx", d.total_tx],
        ["Chain ID", d.chain_id],
        ["ETH transferred", `${fmtNum(d.total_eth_transferred_eth)} ETH`],
        ["Internal value", `${fmtNum(d.total_internal_value_eth)} ETH`],
        ["Range", `${d.start_block} â€“ ${d.end_block}`],
      ];
      kpisEl.innerHTML = items.map(([label, value]) => `
        <div class="kpi"><div class="label">${label}</div><div class="value">${value}</div></div>
      `).join("");

      // Types table
      const tbody = $("#typesTable tbody");
      const entries = Object.entries(d.tx_types || {}).sort((a,b)=> a[0].localeCompare(b[0]));
      tbody.innerHTML = entries.map(([t,v]) => `
        <tr>
          <td><span class="pill">${t}</span></td>
          <td>${fmtNum(v.count)}</td>
          <td>${fmtNum(v.gas_used)}</td>
          <td>${fmtNum(v.avg_gas_price_gwei)}</td>
          <td>${fmtNum(v.eth_value_sum_eth)} ETH</td>
        </tr>
      `).join("");

      // Top contracts
      const cBody = $("#contractsTable tbody");
      cBody.innerHTML = (d.top_contracts_by_tx || []).map(([addr, n], i) =>
        `<tr><td>${i+1}</td><td><code>${addr}</code></td><td>${fmtNum(n)}</td></tr>`
      ).join("");

      // Tokens
      renderTokensTable();

      // Charts
      const ctx1 = document.getElementById("txCountChart");
      const ctx2 = document.getElementById("txShareChart");
      const labels = entries.map(([t]) => t);
      const counts = entries.map(([,v]) => v.count || 0);
      const total = counts.reduce((a,b)=>a+b,0) || 1;
      const shares = counts.map(c => (c/total)*100);

      txCountChart = new Chart(ctx1, {
        type: "bar",
        data: { labels, datasets: [{ label: "Tx count", data: counts }] },
        options: { responsive: true, plugins: { legend: { display: true }, tooltip: { intersect:false } }, scales: { y: { beginAtZero: true } } }
      });
      txShareChart = new Chart(ctx2, {
        type: "doughnut",
        data: { labels, datasets: [{ label: "Share %", data: shares }] },
        options: { responsive: true, plugins: { legend: { position: "right" }, tooltip: { callbacks: { label: (ctx)=> `${ctx.label}: ${fmtNum(ctx.parsed)}%` } } }, cutout: "55%" }
      });
    }

    function renderTokensTable() {
      const tBody = $("#tokensTable tbody");
      tBody.innerHTML = (summary?.top_tokens_by_events || []).map(([addr, n], i) => {
        const meta = tokenMeta[addr?.toLowerCase()];
        const label = meta ? `${meta.symbol || "?"} (${meta.name || "?"}${meta.decimals!=null?`, ${meta.decimals}`:""})` : "â€”";
        return `<tr><td>${i+1}</td><td>${label}</td><td><code>${addr}</code></td><td>${fmtNum(n)}</td></tr>`;
      }).join("");
    }

    // Simple semaphore + backoff/jitter
    function sleep(ms) { return new Promise(r => setTimeout(r, ms)); }
    function jitter(ms) { return ms + Math.floor(Math.random() * (ms * 0.2)); }

    async function rpcCall(method, params) {
      recentCalls++;
      const provider = web3.currentProvider;
      for (let attempt = 0; attempt < 6; attempt++) {
        try {
          const res = await provider.send(method, params);
          recentErrors = Math.max(0, recentErrors - 1);
          return res?.result ?? res;
        } catch (e) {
          recentErrors++;
          const backoff = jitter(250 * (2 ** attempt));
          await sleep(backoff);
        }
      }
      throw new Error(method + " failed");
    }

    async function rpcBatch(calls) {
      // Best-effort JSON-RPC batch; some providers disallow or ignore CORS for batch requests.
      const provider = web3.currentProvider;
      const payload = calls.map((c, i) => ({ jsonrpc: "2.0", id: i+1, method: c[0], params: c[1] }));
      try {
        const res = await provider.send(payload);
        if (!Array.isArray(res)) throw new Error("Batch response not array");
        const byId = new Map(res.map(r => [r.id, r]));
        return payload.map(p => byId.get(p.id)?.result);
      } catch (e) {
        // Fall back to individual calls
        return Promise.all(calls.map(([m, p]) => rpcCall(m, p)));
      }
    }

    // Adaptive concurrency controller
    function tuneConcurrency(base) {
      // If over 10% errors in last window, scale down; else gently scale up.
      if (recentCalls >= 20) {
        const errRate = recentErrors / Math.max(1, recentCalls);
        if (errRate > 0.1) targetConcurrency = Math.max(2, Math.floor(targetConcurrency * 0.6));
        else targetConcurrency = Math.min(base, targetConcurrency + 1);
        recentCalls = 0; recentErrors = 0;
      }
      return targetConcurrency;
    }

    // Concurrency limiter
    async function pLimitMap(items, limit, fn) {
      const ret = new Array(items.length);
      let i = 0;
      const next = async () => {
        const idx = i++;
        if (idx >= items.length) return;
        try { ret[idx] = await fn(items[idx], idx); } catch { ret[idx] = undefined; }
        await next();
      };
      await Promise.all(new Array(Math.min(limit, items.length)).fill(0).map(()=> next()));
      return ret;
    }

    async function connectRPC() {
      const url = rpcInput.value.trim();
      if (!url) { rpcStatus.textContent = "Enter an RPC URL."; return false; }
      web3 = new Web3(new Web3.providers.HttpProvider(url, { timeout: 90000 }));
      const ok = await web3.eth.net.isListening().catch(()=>false);
      rpcStatus.textContent = ok ? "Connected" : "Failed to connect";
      rpcStatus.style.color = ok ? "#22c55e" : "#ef4444";
      return ok;
    }

    function updateProgress(cur, total) {
      const pct = Math.max(0, Math.min(100, Math.round((cur/Math.max(1,total))*100)));
      progressbar.style.width = pct + "%";
    }

    async function getInternalValueForBlock(bnum, mode) {
      try {
        if (mode === "none") return 0n;
        if (mode === "erigon") {
          const res = await rpcCall("trace_block", [Web3.utils.toHex(bnum)]);
          const traces = res || [];
          let total = 0n;
          for (const tr of traces) {
            if (tr?.type === "call") {
              const val = tr?.action?.value || "0x0";
              if (typeof val === "string" && val.startsWith("0x")) total += BigInt(val);
            }
          }
          return total;
        }
        if (mode === "geth") {
          const res = await rpcCall("debug_traceBlockByNumber", [Web3.utils.toHex(bnum), { tracer: "callTracer" }]);
          const calls = res || [];
          let total = 0n;
          const walk = (node) => {
            const v = node?.value;
            if (typeof v === "string" && v.startsWith("0x")) total += BigInt(v);
            (node?.calls || []).forEach(walk);
          };
          for (const txres of calls) {
            const root = txres?.result || txres?.calls || txres;
            if (Array.isArray(root)) root.forEach(r => r && walk(r));
            else if (root) walk(root);
          }
          return total;
        }
      } catch (e) { return 0n; }
      return 0n;
    }

    function toEth(wei) { return Number(Web3.utils.fromWei(String(wei), "ether")); }

    function mergeSummaries(a, b) {
      // Merge two summary objects; approximate avg gas by count-weighted avg
      const out = structuredClone(a);
      out.start_block = Math.min(a.start_block, b.start_block);
      out.end_block = Math.max(a.end_block, b.end_block);
      out.block_count = out.end_block - out.start_block + 1;
      out.total_tx = (a.total_tx||0) + (b.total_tx||0);
      out.total_eth_transferred_eth = (a.total_eth_transferred_eth||0) + (b.total_eth_transferred_eth||0);
      out.total_internal_value_eth = (a.total_internal_value_eth||0) + (b.total_internal_value_eth||0);
      out.unique_senders = -1; out.unique_receivers = -1;

      const tx = {};
      const keys = new Set([...(Object.keys(a.tx_types||{})), ...(Object.keys(b.tx_types||{}))]);
      for (const k of keys) {
        const A = (a.tx_types||{})[k] || {count:0,gas_used:0,avg_gas_price_gwei:0,eth_value_sum_eth:0};
        const B = (b.tx_types||{})[k] || {count:0,gas_used:0,avg_gas_price_gwei:0,eth_value_sum_eth:0};
        const count = A.count + B.count;
        const gas_used = A.gas_used + B.gas_used;
        const sum_gwei = (A.avg_gas_price_gwei||0) * A.count + (B.avg_gas_price_gwei||0) * B.count;
        const avg_gas_price_gwei = count ? Math.round((sum_gwei / count) * 10000)/10000 : 0;
        const eth_value_sum_eth = (A.eth_value_sum_eth||0) + (B.eth_value_sum_eth||0);
        tx[k] = { count, gas_used, avg_gas_price_gwei, eth_value_sum_eth };
      }
      out.tx_types = tx;

      const addToMap = (map, arr) => (arr||[]).forEach(([addr, n]) => { map[addr] = (map[addr]||0)+n; });
      const contractsMap = {}; addToMap(contractsMap, a.top_contracts_by_tx); addToMap(contractsMap, b.top_contracts_by_tx);
      const tokensMap = {}; addToMap(tokensMap, a.top_tokens_by_events); addToMap(tokensMap, b.top_tokens_by_events);
      out.top_contracts_by_tx = Object.entries(contractsMap).sort((x,y)=>y[1]-x[1]).slice(0,20);
      out.top_tokens_by_events = Object.entries(tokensMap).sort((x,y)=>y[1]-x[1]).slice(0,20);

      out.notes = Array.from(new Set([...(a.notes||[]), ...(b.notes||[]), "Merged in browser"]));
      out.limits = Object.assign({}, a.limits || {}, b.limits || {});
      return out;
    }

    function renderTokensAfterResolve() {
      tokenSubtitle.textContent = " â€” symbols resolved";
      renderTokensTable();
    }

    async function runProfiler(resume=false) {
      resetUI();
      runStatus.textContent = "Connecting...";
      const ok = await connectRPC();
      if (!ok) { return; }

      const start = Number(startBlock.value);
      const end = Number(endBlock.value);
      const page = Math.max(1, Number(pageSize.value));
      const concBase = Math.max(1, Number(concurrency.value));
      targetConcurrency = concBase; // reset target
      const doSkipContract = !!skipContract.checked;
      const doBatch = !!enableBatch.checked;
      const txCapN = Number(txCap.value || "0") || null;
      const trace = traceMode.value;

      if (!Number.isFinite(start) || !Number.isFinite(end) || end < start) {
        runStatus.textContent = "Invalid range"; return;
      }

      // Resume point
      let currentStart = start;
      const st = resume ? loadState() : null;
      if (st && st.rpc === rpcInput.value && st.end === end && st.page === page) {
        currentStart = Math.min(end, Math.max(start, st.nextBlock || start));
        perBlockRows = st.perBlockRows || [];
        summary = st.partialSummary || null;
      } else if (resume) {
        runStatus.textContent = "No matching resume state."; return;
      }

      runStatus.textContent = "Running...";
      tokenMeta = {};
      let totalTx = summary?.total_tx || 0;
      let totalEth = BigInt(Web3.utils.toWei(String(summary?.total_eth_transferred_eth||0), "ether"));
      let internalWei = BigInt(Web3.utils.toWei(String(summary?.total_internal_value_eth||0), "ether"));
      const txTypeStats = summary?.tx_types ? Object.fromEntries(Object.entries(summary.tx_types).map(([k,v]) => [k, { count:v.count, gas_used:v.gas_used, gas_price_wei_sum: BigInt(Math.round((v.avg_gas_price_gwei||0)*1e9*v.count)), eth_value_wei_sum: BigInt(Web3.utils.toWei(String(v.eth_value_sum_eth||0), "ether")) }])) : {};
      const topContracts = Object.fromEntries((summary?.top_contracts_by_tx||[]).map(([a,n])=>[a,n]));
      const topTokens = Object.fromEntries((summary?.top_tokens_by_events||[]).map(([a,n])=>[a,n]));
      const contractCodeCache = {};

      const countType = (type) => {
        const s = txTypeStats[type] || (txTypeStats[type] = { count:0, gas_used:0, gas_price_wei_sum:0n, eth_value_wei_sum:0n });
        return s;
      };

      const classifyTx = (tx, rc) => {
        if (!tx.to) return ["contract_creation", null];
        const [typ, tokenAddr] = classifyFromLogs(rc.logs || []);
        if (typ === "other_contract_call") {
          if (BigInt(tx.value || 0) > 0n) return ["eth_transfer", null];
          if (!doSkipContract) {
            const addr = tx.to.toLowerCase();
            return [contractCodeCache[addr] ? "other_contract_call" : "other_eoa_call", null];
          }
        }
        return [typ, tokenAddr];
      };

      const blocksTotal = end - start + 1;
      for (let cur = currentStart; cur <= end; cur += page) {
        const chunkEnd = Math.min(end, cur + page - 1);
        const blockNums = []; for (let b = cur; b <= chunkEnd; b++) blockNums.push(b);

        // Batch getBlock
        let blocks = [];
        if (doBatch) {
          const calls = blockNums.map(b => ["eth_getBlockByNumber", [Web3.utils.toHex(b), true]]);
          const res = await rpcBatch(calls);
          blocks = res.map(r => (r && r.number) ? web3.eth.abi.decodeParameters([], []) || r : r); // keep as raw
        } else {
          const conc = tuneConcurrency(concBase);
          blocks = await pLimitMap(blockNums, conc, async (bnum) => {
            try { return await web3.eth.getBlock(bnum, true); } catch { return null; }
          });
        }

        // Contract code cache fill
        if (!doSkipContract) {
          const addrs = [];
          for (const blk of blocks) if (blk) {
            for (const tx of (blk.transactions || [])) if (tx.to) {
              const a = tx.to.toLowerCase();
              if (contractCodeCache[a] === undefined) addrs.push(a);
            }
          }
          const uniq = Array.from(new Set(addrs));
          // Try batch getCode
          if (doBatch && uniq.length) {
            const calls = uniq.map(a => ["eth_getCode", [a, "latest"]]);
            const results = await rpcBatch(calls);
            uniq.forEach((addr, i) => {
              const code = results[i];
              contractCodeCache[addr] = !!(code && code !== "0x" && code !== "0x00");
            });
          } else {
            const conc = Math.min(tuneConcurrency(concBase), 8);
            await pLimitMap(uniq, conc, async (addr) => {
              try {
                const code = await web3.eth.getCode(addr);
                contractCodeCache[addr] = !!(code && code !== "0x" && code !== "0x00");
              } catch { contractCodeCache[addr] = true; }
            });
          }
        }

        // Receipts
        for (const blk of blocks) {
          if (!blk) continue;
          const txs = blk.transactions || [];
          // Try batch receipts
          let receipts = [];
          if (doBatch && txs.length) {
            const calls = txs.map(tx => ["eth_getTransactionReceipt", [tx.hash]]);
            receipts = await rpcBatch(calls);
          } else {
            const conc = tuneConcurrency(concBase);
            receipts = await pLimitMap(txs, conc, async (tx) => {
              try { return await web3.eth.getTransactionReceipt(tx.hash); } catch { return null; }
            });
          }

          let blockCounts = {}; let blockGasUsed = 0n;
          for (let i = 0; i < txs.length; i++) {
            const tx = txs[i], rc = receipts[i];
            if (!rc) continue;
            totalTx += 1;
            const gasUsed = BigInt(rc.gasUsed || 0); blockGasUsed += gasUsed;
            const gasPrice = BigInt(tx.gasPrice || 0);
            const value = BigInt(tx.value || 0);

            const [typ, tokenAddr] = classifyTx(tx, rc);
            const s = countType(typ);
            s.count += 1;
            s.gas_used += Number(gasUsed);
            s.gas_price_wei_sum += gasPrice;
            s.eth_value_wei_sum += value;

            blockCounts[typ] = (blockCounts[typ] || 0) + 1;
            totalEth += value;

            if (tx.to) {
              const lc = tx.to.toLowerCase();
              topContracts[lc] = (topContracts[lc] || 0) + 1;
            }
            if (tokenAddr) {
              const lc = tokenAddr.toLowerCase();
              topTokens[lc] = (topTokens[lc] || 0) + 1;
            }

            if (txCapN && totalTx >= txCapN) break;
          }

          perBlockRows.push([blk.number, blk.timestamp, txs.length, DEFAULT_TYPES.map(t => blockCounts[t] || 0).join("|"), Number(blockGasUsed), Number(blk.gasLimit || 0)]);
          if (txCapN && totalTx >= txCapN) break;
        }

        // Internal traces
        if (trace !== "none") {
          if (doBatch) {
            const calls = blockNums.map(b => trace === "erigon"
              ? ["trace_block", [Web3.utils.toHex(b)]]
              : ["debug_traceBlockByNumber", [Web3.utils.toHex(b), { tracer: "callTracer" }]]);
            const results = await rpcBatch(calls);
            for (let i=0;i<blockNums.length;i++) {
              const res = results[i];
              if (!res) continue;
              if (trace === "erigon") {
                for (const tr of (res||[])) {
                  if (tr?.type === "call") {
                    const v = tr?.action?.value || "0x0";
                    if (typeof v === "string" && v.startsWith("0x")) internalWei += BigInt(v);
                  }
                }
              } else {
                const walk = (node) => {
                  const v = node?.value;
                  if (typeof v === "string" && v.startsWith("0x")) internalWei += BigInt(v);
                  (node?.calls || []).forEach(walk);
                };
                for (const txres of (res||[])) {
                  const root = txres?.result || txres?.calls || txres;
                  if (Array.isArray(root)) root.forEach(r => r && walk(r));
                  else if (root) walk(root);
                }
              }
            }
          } else {
            for (const bnum of blockNums) {
              internalWei += await getInternalValueForBlock(bnum, trace);
            }
          }
        }

        updateProgress(chunkEnd - start + 1, blocksTotal);

        // Save resume checkpoint
        const partialSummary = buildSummaryObject(start, end, totalTx, totalEth, internalWei, txTypeStats, topContracts, topTokens);
        saveState({ rpc: rpcInput.value, end, page, nextBlock: chunkEnd + 1, perBlockRows, partialSummary });

        if (txCapN && totalTx >= txCapN) break;
      }

      // Final summary
      summary = buildSummaryObject(start, end, totalTx, totalEth, internalWei, txTypeStats, topContracts, topTokens);
      clearState();
      renderAll();
      runStatus.textContent = "Done";
      updateProgress(1,1);
    }

    function buildSummaryObject(start, end, totalTx, totalEthWei, internalWei, txTypeStats, topContracts, topTokens) {
      const tx_types = {};
      for (const [k,v] of Object.entries(txTypeStats)) {
        const avgGwei = v.count ? Number(v.gas_price_wei_sum) / v.count / 1e9 : 0;
        tx_types[k] = {
          count: v.count,
          gas_used: v.gas_used,
          avg_gas_price_gwei: Math.round(avgGwei * 10000) / 10000,
          eth_value_sum_eth: toEth(v.eth_value_wei_sum),
        };
      }
      const topContractsSorted = Object.entries(topContracts).sort((a,b)=> b[1]-a[1]).slice(0,20);
      const topTokensSorted = Object.entries(topTokens).sort((a,b)=> b[1]-a[1]).slice(0,20);
      return {
        start_block: start,
        end_block: end,
        chain_id: web3 ? Number(web3.eth.getChainId()) : undefined,
        block_count: end - start + 1,
        total_tx: totalTx,
        unique_senders: -1,
        unique_receivers: -1,
        total_eth_transferred_eth: toEth(totalEthWei),
        total_internal_value_eth: toEth(internalWei),
        tx_types,
        top_contracts_by_tx: topContractsSorted,
        top_tokens_by_events: topTokensSorted,
        notes: [
          "Browser runner with adaptive concurrency and optional batch JSONâ€‘RPC.",
          "Use the Python CLI for massive ranges and consistent tracing.",
        ],
        limits: {}
      };
    }

    connectBtn.addEventListener("click", connectRPC);
    runBtn.addEventListener("click", ()=> runProfiler(false));
    resumeBtn.addEventListener("click", ()=> runProfiler(true));

    // Export files
    function dl(name, text, mime="application/json") {
      const a = document.createElement("a");
      a.href = URL.createObjectURL(new Blob([text], {type:mime}));
      a.download = name;
      document.body.appendChild(a); a.click(); a.remove();
    }
    $("#exportJson").addEventListener("click", ()=> {
      if (!summary) { runStatus.textContent = "Nothing to export yet."; return; }
      dl("summary.json", JSON.stringify(summary, null, 2));
    });
    $("#exportCsv").addEventListener("click", ()=> {
      if (!perBlockRows.length) { runStatus.textContent = "No per-block data yet."; return; }
      const header = ["block_number","timestamp","tx_count","eth_transfer","contract_creation","erc20_transfer","erc721_transfer","erc1155_transfer","other_contract_call","mixed_token_activity","other_eoa_call","block_gas_used","block_gas_limit"];
      const lines = [header.join(",")].concat(perBlockRows.map(r => r.join(",")));
      dl("per_block.csv", lines.join("\n"), "text/csv");
    });

    // Resolve ERC-20 symbols for tokens table
    $("#resolveTokens").addEventListener("click", async ()=> {
      if (!summary) { runStatus.textContent = "Run profiler or load a summary first."; return; }
      if (!web3) { runStatus.textContent = "Connect an RPC first."; return; }
      tokenSubtitle.textContent = " â€” resolvingâ€¦";
      const addrs = (summary.top_tokens_by_events || []).map(([addr]) => addr);
      const out = {};
      for (const a of addrs) {
        try {
          const c = new web3.eth.Contract(ERC20_ABI, a);
          const [name, symbol, decimals] = await Promise.all([
            c.methods.name().call(), c.methods.symbol().call(), c.methods.decimals().call()
          ]);
          out[a.toLowerCase()] = { name, symbol, decimals: Number(decimals) };
        } catch {
          out[a.toLowerCase()] = { name: "Unknown", symbol: "?", decimals: null };
        }
      }
      tokenMeta = out;
      renderTokensAfterResolve();
    });

    // Merge uploaded summary.json
    mergeInput.addEventListener("change", (e) => {
      const f = e.target.files?.[0];
      if (!f) return;
      const reader = new FileReader();
      reader.onload = () => {
        try {
          const other = JSON.parse(reader.result);
          if (!summary) { summary = other; renderAll(); return; }
          summary = mergeSummaries(summary, other);
          renderAll();
          runStatus.textContent = "Merged summary.json";
        } catch { runStatus.textContent = "Invalid JSON for merge."; }
      };
      reader.readAsText(f);
    });
  </script>
</body>
</html>
