<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>EVM Profiler â€” All-in-One Browser Runner</title>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap" rel="stylesheet">
  <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.1/dist/chart.umd.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/web3@1.10.4/dist/web3.min.js"></script>
  <style>
    :root {
      --bg:#0f1115;
      --panel:#171a21;
      --muted:#9aa4b2;
      --fg:#e5e7eb;
      --accent:#4f46e5;
      --accent-soft:#6366f1;
      --card:#1f2430;
      --border:#2b3240;
      --good:#22c55e;
      --bad:#ef4444;
      --warn:#f59e0b;
    }
    * { box-sizing: border-box; }
    body {
      margin:0;
      padding:0 16px 60px;
      font-family:"Inter",system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif;
      background:linear-gradient(180deg,#0f1115,#0b0d11);
      color:var(--fg);
    }
    header {
      position:sticky;
      top:0;
      background:rgba(15,17,21,.88);
      backdrop-filter:blur(10px);
      z-index:10;
      padding:14px 0 10px;
    }
    .wrap { max-width: 1240px; margin: 0 auto; }
    h1 {
      margin:8px 0 0;
      font-size:22px;
      font-weight:700;
      letter-spacing:.2px;
    }
    p.small {
      color:var(--muted);
      margin:6px 0 0;
      font-size:13px;
    }
    .toolbar, .row {
      display:flex;
      gap:10px;
      align-items:center;
      flex-wrap:wrap;
    }
    .toolbar { margin:14px 0 0; }
    .box {
      display:flex;
      align-items:center;
      gap:8px;
      padding:12px 12px 14px;
      border:1px solid var(--border);
      border-radius:12px;
      background:var(--panel);
    }
    input[type="text"], input[type="number"], select, textarea {
      padding:8px 10px;
      border-radius:8px;
      border:1px solid var(--border);
      background:#0c0f14;
      color:var(--fg);
      font-size:13px;
    }
    input[type="text"] { width:520px; max-width:70vw; }
    textarea { width:100%; min-height: 72px; resize:vertical; }
    .btn {
      border:1px solid var(--border);
      background:var(--panel);
      color:var(--fg);
      padding:9px 12px;
      border-radius:10px;
      cursor:pointer;
      font-size:13px;
      transition:background .12s ease, transform .05s ease, box-shadow .15s ease, border-color .12s ease;
      display:inline-flex;
      align-items:center;
      gap:6px;
    }
    .btn:hover:not(:disabled) {
      background:#202535;
      transform:translateY(-0.5px);
      box-shadow:0 0 0 1px rgba(148,163,184,.2);
    }
    .btn:disabled {
      opacity:0.45;
      cursor:default;
      box-shadow:none;
      transform:none;
    }

    /* Emphasized RUN / STOP */
    .btn.run-main {
      background:var(--accent);
      border-color:#3730a3;
      font-weight:600;
      padding:11px 18px;
      border-radius:999px;
      box-shadow:0 0 0 1px rgba(129,140,248,.35), 0 8px 18px rgba(79,70,229,.45);
    }
    .btn.run-main:hover:not(:disabled) {
      background:var(--accent-soft);
      box-shadow:0 0 0 1px rgba(191,219,254,.6), 0 9px 22px rgba(79,70,229,.65);
      transform:translateY(-0.5px);
    }
    .btn.stop-main {
      background:var(--bad);
      border-color:#b91c1c;
      font-weight:600;
      padding:11px 16px;
      border-radius:999px;
      box-shadow:0 0 0 1px rgba(248,113,113,.6), 0 6px 16px rgba(239,68,68,.6);
    }
    .btn.stop-main:hover:not(:disabled) {
      background:#f97373;
      box-shadow:0 0 0 1px rgba(254,202,202,.8), 0 8px 18px rgba(239,68,68,.8);
      transform:translateY(-0.5px);
    }

    .status { color:var(--muted); font-size:12px; }
    .grid { display:grid; grid-template-columns: 1fr; gap:16px; margin-top:18px; }
    .panel {
      background:var(--card);
      border:1px solid var(--border);
      border-radius:14px;
      padding:16px;
    }
    .panel h2 { margin:0 0 10px; font-size:18px; }
    .kpis {
      display:grid;
      grid-template-columns: repeat(auto-fill, minmax(200px,1fr));
      gap:12px;
      margin-top:12px;
    }
    .kpi {
      background: var(--card);
      border:1px solid var(--border);
      border-radius:14px;
      padding:14px;
    }
    .kpi .label { color: var(--muted); font-size:12px; }
    .kpi .value { font-size:22px; font-weight:700; margin-top:4px; }
    .flex { display:flex; gap:16px; flex-wrap: wrap; }
    .grow { flex:1; min-width: 320px; }
    table { width:100%; border-collapse: collapse; }
    th, td { padding:10px; border-bottom:1px solid var(--border); font-size: 13px; }
    th { text-align:left; color: var(--muted); font-weight:600; }
    tr:hover { background: rgba(255,255,255,0.03); }
    .pill { display:inline-block; padding:3px 8px; border-radius:999px; background: #0e7490; font-size:12px; }
    .muted { color: var(--muted); }

    /* More prominent progress bar */
    .progress {
      height: 16px;
      background: radial-gradient(circle at top, #020617, #020617) padding-box;
      border:1px solid #1f2937;
      border-radius:999px;
      overflow:hidden;
      box-shadow:0 0 0 1px rgba(15,23,42,.7), 0 0 12px rgba(59,130,246,.4) inset;
    }
    .progress > div {
      height: 100%;
      background: linear-gradient(90deg,#4f46e5,#22c55e);
      width: 0%;
      transition: width .2s ease;
      box-shadow:0 0 14px rgba(129,140,248,.9);
    }

    .sep { height: 12px; }
    .heartbeat { display:inline-flex; align-items:center; gap:6px; margin-left:6px; }
    .dot {
      width:10px; height:10px; border-radius:50%;
      background: var(--bad);
      box-shadow: 0 0 0 0 rgba(34,197,94,0.7);
      transition: background .2s ease, box-shadow .2s ease;
    }
    .dot.ok {
      background: var(--good);
      box-shadow: 0 0 0 8px rgba(34,197,94,0);
      animation: pulse 1.5s infinite;
    }
    .dot.warn {
      background: var(--warn);
      box-shadow: none;
      animation: none;
    }
    @keyframes pulse {
      0% { box-shadow: 0 0 0 0 rgba(34,197,94,.55);}
      70% { box-shadow: 0 0 0 12px rgba(34,197,94,0);}
      100% { box-shadow: 0 0 0 0 rgba(34,197,94,0);}
    }
    .micro { font-size:11px; color:var(--muted); }
    .spacer { flex:1; }
    .grid-2 { display:grid; grid-template-columns: 1fr 1fr; gap:14px; }
    @media (max-width: 1024px){
      .grid-2 { grid-template-columns: 1fr; }
    }
  </style>
</head>
<body>
  <header>
    <div class="wrap">
      <h1>ðŸ“Š EVM Profiler â€” All-in-One Browser Runner</h1>
      <p class="small">
        Providers â€¢ RPS limits & retries â€¢ heartbeat â€¢ STOP â€¢ ETA â€¢ presets â€¢ Spamoor export â€¢ JSON/CSV/NDJSON â€¢
        token metadata â€¢ live charts â€” all in a single HTML file.
      </p>
      <div class="toolbar">
        <div class="box" style="flex:1; flex-wrap:wrap; gap:10px 16px;">
          <div class="row">
            <strong>RPC</strong>
            <input id="rpcInput" type="text" placeholder="https://mainnet.infura.io/v3/YOUR_KEY" />
            <button id="connectBtn" class="btn">Connect</button>
            <span id="rpcStatus" class="status"></span>
            <span class="heartbeat"><span id="hbDot" class="dot"></span><span id="hbText" class="status">idle</span></span>
          </div>
          <div class="row">
            <div>Provider</div>
            <select id="providerProfile">
              <option value="custom" selected>Custom</option>
              <option value="infura">Infura</option>
              <option value="alchemy">Alchemy</option>
              <option value="erigon">Erigon (self-hosted)</option>
              <option value="public">Public Node</option>
              <option value="local">Local (Geth/Nethermind)</option>
            </select>
            <div>Start</div><input id="startBlock" type="number" value="0" style="width:120px;">
            <div>End</div><input id="endBlock" type="number" value="0" style="width:120px;">
            <div>Page</div><input id="pageSize" type="number" value="200" style="width:90px;">
            <div>Conc.</div><input id="concurrency" type="number" value="8" style="width:80px;">
            <label><input id="skipContract" type="checkbox" checked> Skip contract check</label>
            <label class="inline"><input id="logsOnly" type="checkbox"> Logs-only</label>
            <label class="inline"><input id="dualPass" type="checkbox"> Dual-pass</label>
            <div>Tx cap</div><input id="txCap" type="number" value="" placeholder="optional" style="width:120px;">
            <!-- Emphasized RUN / STOP buttons -->
            <button id="runBtn" class="btn run-main">â–¶ Run</button>
            <button id="stopBtn" class="btn stop-main" disabled>â–  Stop</button>
          </div>
          <div class="row">
            <strong>Preset</strong>
            <input id="presetName" type="text" placeholder="e.g., infura-20000000-20001000" style="width:240px;">
            <button id="savePreset" class="btn">Save</button>
            <select id="presetSelect" style="min-width:240px;"></select>
            <button id="loadPreset" class="btn">Load</button>
            <button id="deletePreset" class="btn">Delete</button>
            <span id="presetStatus" class="status"></span>
          </div>
          <div class="row">
            <button id="exportJson" class="btn">summary.json</button>
            <button id="exportCsv" class="btn">per_block.csv</button>
            <button id="exportNdjson" class="btn">per_block.ndjson</button>
            <div class="spacer"></div>
            <div class="radio">
              <label><input type="radio" name="yamlMode" value="single" checked> Spamoor: Single YAML</label>
              <label><input type="radio" name="yamlMode" value="multiple"> Multiple</label>
            </div>
            <button id="exportSpamoor" class="btn">Export YAML</button>
            <button id="exportSpamoorZip" class="btn">ZIP</button>
            <span id="runStatus" class="status"></span>
          </div>
          <div class="progress" style="flex:1; max-width: 860px; margin-top:4px;">
            <div id="progressbar"></div>
          </div>
          <div class="micro" id="blockProgressText"></div>
          <div class="micro" id="finishTimeText"></div>
        </div>
      </div>
    </div>
  </header>

  <main class="wrap">
    <section class="kpis" id="kpis"></section>
    <div class="sep"></div>

    <section class="grid">
      <div class="panel">
        <h2>Transaction types</h2>
        <div class="flex">
          <div class="grow"><canvas id="txCountChart" height="260"></canvas></div>
          <div class="grow"><canvas id="txShareChart" height="260"></canvas></div>
        </div>
      </div>

      <div class="panel">
        <h2>Tables</h2>
        <div style="overflow:auto;">
          <table id="typesTable">
            <thead>
              <tr>
                <th>Type</th>
                <th>Count</th>
                <th>Gas used</th>
                <th>Avg gas price (gwei)</th>
                <th>ETH value sum</th>
              </tr>
            </thead>
            <tbody></tbody>
          </table>
        </div>
      </div>

      <div class="panel">
        <h2>Token metadata (ERC-20)</h2>
        <div class="grid-2">
          <div>
            <p class="small">
              Paste token contract addresses (one per line), or click
              <strong>Collect from run</strong> to grab all token addresses observed in ERC-20/721/1155 logs.
              After each run, the profiler also auto-resolves a small set of top tokens.
            </p>
            <textarea id="tokenInput" placeholder="0xdAC17F958D2ee523a2206206994597C13D831ec7&#10;0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48"></textarea>
            <div class="row" style="margin-top:8px;">
              <button id="collectTokens" class="btn">Collect from run</button>
              <button id="resolveTokens" class="btn primary">Resolve name/symbol/decimals</button>
              <span id="tokenStatus" class="status"></span>
            </div>
          </div>
          <div>
            <div class="row">
              <button id="exportTokenCache" class="btn">Export cache JSON</button>
              <input id="importTokenFile" type="file" accept="application/json" style="display:none;">
              <button id="importTokenCache" class="btn">Import cache JSON</button>
            </div>
            <div style="overflow:auto; max-height: 280px; border:1px solid var(--border); border-radius:12px; margin-top:8px;">
              <table id="tokenTable" style="width:100%;">
                <thead><tr><th>Address</th><th>Symbol</th><th>Name</th><th>Decimals</th></tr></thead>
                <tbody></tbody>
              </table>
            </div>
          </div>
        </div>
      </div>
    </section>
  </main>

  <!-- JS: logic identical to previous version, only UI styling changed -->
  <script>
    const $ = (sel) => document.querySelector(sel);
    const storageKey = "evm-profiler-ui-v3";
    const presetsKey = "evm-profiler-presets";
    const tokenKey = "evm-profiler-token-cache";

    const fields = ["rpcInput","providerProfile","startBlock","endBlock","pageSize","concurrency","skipContract","logsOnly","dualPass","txCap"];
    function collectSettings() {
      const data = {};
      for (const id of fields){
        const el = document.getElementById(id);
        if (!el) continue;
        if (el.type === "checkbox") data[id] = !!el.checked;
        else if (el.tagName === "SELECT") data[id] = el.value;
        else data[id] = el.value;
      }
      return data;
    }
    function applySettings(data){
      for (const [id, val] of Object.entries(data||{})){
        const el = document.getElementById(id);
        if (!el) continue;
        if (el.type === "checkbox") el.checked = !!val;
        else el.value = val;
      }
    }
    function saveSettings(){ localStorage.setItem(storageKey, JSON.stringify(collectSettings())); }
    function loadSettings(){ try{ const raw=localStorage.getItem(storageKey); if(raw) applySettings(JSON.parse(raw)); } catch{} }
    window.addEventListener("load", loadSettings);
    document.addEventListener("change", (e)=>{ if (e.target && fields.includes(e.target.id)) saveSettings(); });
    document.addEventListener("input", (e)=>{ if (e.target && fields.includes(e.target.id)) saveSettings(); });

    const presetName = $("#presetName");
    const presetSelect = $("#presetSelect");
    const presetStatus = $("#presetStatus");
    function loadPresetList(){
      const all = JSON.parse(localStorage.getItem(presetsKey)||"{}");
      presetSelect.innerHTML = "";
      const names = Object.keys(all).sort();
      for (const n of names){
        const opt = document.createElement("option"); opt.value=n; opt.textContent=n; presetSelect.appendChild(opt);
      }
      return all;
    }
    function savePreset(){
      const name = (presetName.value||"").trim();
      if (!name){ presetStatus.textContent="Name required"; return; }
      const all = loadPresetList();
      all[name] = collectSettings();
      localStorage.setItem(presetsKey, JSON.stringify(all));
      loadPresetList();
      presetSelect.value = name;
      presetStatus.textContent = "Saved.";
      setTimeout(()=> presetStatus.textContent="", 1500);
    }
    function loadPresetByName(name){
      const all = loadPresetList();
      const data = all[name];
      if (!data){ presetStatus.textContent="Not found"; return; }
      applySettings(data);
      saveSettings();
      presetStatus.textContent = "Loaded.";
      setTimeout(()=> presetStatus.textContent="", 1500);
    }
    function deletePreset(){
      const name = presetSelect.value;
      if (!name){ presetStatus.textContent="Select a preset"; return; }
      const all = loadPresetList();
      delete all[name];
      localStorage.setItem(presetsKey, JSON.stringify(all));
      loadPresetList();
      presetStatus.textContent = "Deleted.";
      setTimeout(()=> presetStatus.textContent="", 1500);
    }
    $("#savePreset").addEventListener("click", savePreset);
    $("#loadPreset").addEventListener("click", ()=> loadPresetByName(presetSelect.value));
    $("#deletePreset").addEventListener("click", deletePreset);
    loadPresetList();

    let web3 = null;
    let summary = null;
    let perBlockRows = [];
    let cancelRequested = false;
    let lastHeartbeat = 0;
    let hbTimer = null;

    const hbDot = $("#hbDot");
    const hbText = $("#hbText");
    const runBtn = $("#runBtn");
    const stopBtn = $("#stopBtn");
    const runStatus = $("#runStatus");
    const progressbar = $("#progressbar");
    const blockProgressText = $("#blockProgressText");
    const finishTimeText = $("#finishTimeText");

    function beat(msg="active"){ lastHeartbeat = Date.now(); hbDot.className="dot ok"; hbText.textContent = msg; }
    function heartbeatLoop(){
      if (hbTimer) clearInterval(hbTimer);
      hbTimer = setInterval(()=>{
        const dt = Date.now() - lastHeartbeat;
        if (dt < 4000) { hbDot.className="dot ok"; hbText.textContent = "active"; }
        else if (dt < 10000) { hbDot.className="dot warn"; hbText.textContent = "quietâ€¦"; }
        else { hbDot.className="dot"; hbText.textContent = "stalled?"; }
      }, 1000);
    }
    heartbeatLoop();

    function updateProgress(cur,total){
      const pct=Math.max(0,Math.min(100,Math.round((cur/Math.max(1,total))*100)));
      progressbar.style.width=pct+"%";
    }
    function fmtETA(sec){
      if (sec==null || !isFinite(sec)) return "";
      const d = new Date(Date.now() + Math.max(0, sec*1000));
      const hh = d.getHours().toString().padStart(2,"0");
      const mm = d.getMinutes().toString().padStart(2,"0");
      const ss = d.getSeconds().toString().padStart(2,"0");
      return `${d.toLocaleDateString()} ${hh}:${mm}:${ss}`;
    }
    let startBlockVal = 0;
    function setBlockProgress(current, end, etaSec=null){
      const pct = Math.max(0, Math.min(100, Math.round(((current - startBlockVal + 1) / (end - startBlockVal + 1))*100)));
      blockProgressText.textContent = `Blocks: ${current} / ${end} (${pct}% complete)` + (etaSec!==null?` â€“ ETA ~${Math.max(0, Math.round(etaSec))}s`:"");
      finishTimeText.textContent = etaSec!=null ? `Estimated finish time: ${fmtETA(etaSec)}` : "";
    }
    function disableRunUI(disabled){ runBtn.disabled=disabled; stopBtn.disabled=!disabled; }

    const presets = {
      custom: { rps: 8, maxRetries: 3, backoffBase: 250, backoffMaxMs: 4000 },
      infura:   { logsStep: 2000, page: 150, conc: 6, rps: 10, maxRetries: 5, backoffBase: 250, backoffMaxMs: 5000 },
      alchemy:  { logsStep: 2500, page: 180, conc: 8, rps: 12, maxRetries: 5, backoffBase: 200, backoffMaxMs: 4500 },
      erigon:   { logsStep: 6000, page: 400, conc: 12, rps: 30, maxRetries: 3, backoffBase: 100, backoffMaxMs: 2000 },
      public:   { logsStep: 1200, page: 120, conc: 4, rps: 4, maxRetries: 6, backoffBase: 400, backoffMaxMs: 8000 },
      local:    { logsStep: 8000, page: 500, conc: 16, rps: 40, maxRetries: 2, backoffBase: 80, backoffMaxMs: 1500 },
    };
    const providerProfile = $("#providerProfile");
    const pageSize = $("#pageSize");
    const concurrency = $("#concurrency");
    providerProfile.addEventListener("change", ()=>{
      const p = presets[providerProfile.value] || {};
      if (p.page) pageSize.value = p.page;
      if (p.conc) concurrency.value = p.conc;
      saveSettings();
    });

    class RateLimiter {
      constructor(rps){ this.minInterval = Math.max(1, Math.floor(1000 / Math.max(1, rps||8))); this.queue = []; this.active = false; this.last = 0; }
      schedule(fn){ return new Promise((resolve,reject)=>{ this.queue.push({fn,resolve,reject}); this.pump(); }); }
      pump(){
        if (this.active) return;
        this.active = true;
        const step=()=>{
          if (!this.queue.length){ this.active=false; return; }
          const now=Date.now();
          const wait=Math.max(0, this.minInterval - (now - this.last));
          setTimeout(()=>{
            const item=this.queue.shift();
            this.last=Date.now();
            Promise.resolve().then(item.fn).then(item.resolve).catch(item.reject).finally(()=>step());
          }, wait);
        };
        step();
      }
    }
    function jitter(ms){ return ms + Math.floor(Math.random()*Math.min(250, ms/2)); }
    async function withRetry(fn, {maxRetries=4, backoffBase=200, backoffMaxMs=5000}={}){
      let attempt=0; let lastErr=null;
      while (attempt<=maxRetries){
        try { return await fn(); } catch (e){
          lastErr=e;
          const delay=Math.min(backoffMaxMs, Math.pow(2,attempt)*backoffBase);
          await new Promise(r=>setTimeout(r, jitter(delay)));
          attempt++;
        }
      }
      throw lastErr;
    }

    let limiter = new RateLimiter(presets.custom.rps);
    function updateLimiter(){ const p = presets[providerProfile.value] || presets.custom; limiter = new RateLimiter(p.rps || presets.custom.rps); }
    function rpcCall(fn, args, opts={}){
      const p = presets[providerProfile.value] || presets.custom;
      return limiter.schedule(()=> withRetry(()=> fn(...args), {maxRetries: p.maxRetries, backoffBase: p.backoffBase, backoffMaxMs: p.backoffMaxMs}));
    }

    const rpcInput = $("#rpcInput");
    const connectBtn = $("#connectBtn");
    const rpcStatus = $("#rpcStatus");
    async function connectRPC(){
      const url=rpcInput.value.trim();
      if(!url){ rpcStatus.textContent="Enter an RPC URL."; return false; }
      updateLimiter();
      web3=new Web3(new Web3.providers.HttpProvider(url,{timeout:60000}));
      const ok=await withRetry(()=> web3.eth.net.isListening(), {maxRetries:2, backoffBase:200, backoffMaxMs:2000}).catch(()=>false);
      rpcStatus.textContent= ok ? "Connected" : "Failed to connect";
      rpcStatus.style.color= ok ? "#22c55e" : "#ef4444";
      if (ok) beat("rpc ok");
      return ok;
    }
    connectBtn.addEventListener("click", connectRPC);

    const startBlockEl = $("#startBlock");
    const endBlockEl = $("#endBlock");
    const logsOnly = $("#logsOnly");
    const dualPass = $("#dualPass");
    const skipContract = $("#skipContract");
    const txCap = $("#txCap");

    let txCountChart = null;
    let txShareChart = null;
    function renderCharts(){
      const ctx1 = document.getElementById("txCountChart");
      const ctx2 = document.getElementById("txShareChart");
      const entries = Object.entries(summary?.tx_types || {})
        .map(([k,v])=>({type:k, count: v.count||0}))
        .filter(x=>x.count>0)
        .sort((a,b)=> b.count - a.count);

      const labels = entries.map(x=>x.type);
      const counts = entries.map(x=>x.count);
      const total = counts.reduce((a,b)=>a+b,0) || 1;
      const shares = counts.map(c => +(c*100/total).toFixed(2));

      if (txCountChart) { txCountChart.destroy(); }
      if (txShareChart) { txShareChart.destroy(); }

      txCountChart = new Chart(ctx1, {
        type: "bar",
        data: { labels, datasets: [{ label: "Tx count", data: counts }] },
        options: {
          responsive: true,
          plugins: { legend: { display: false }, tooltip: { callbacks: { label: (ctx)=>`${ctx.raw} tx` } } },
          scales: { x: { ticks: { color: "#9aa4b2" }}, y: { ticks: { color: "#9aa4b2" } } }
        }
      });

      txShareChart = new Chart(ctx2, {
        type: "doughnut",
        data: { labels, datasets: [{ label: "Share %", data: shares }] },
        options: {
          responsive: true,
          plugins: {
            legend: { position: "bottom", labels: { color: "#e5e7eb" } },
            tooltip: { callbacks: { label: (ctx)=> `${ctx.label}: ${ctx.raw}%` } }
          },
          cutout: "55%"
        }
      });
    }

    function renderTables(){
      const tbody=$("#typesTable tbody");
      const entries=Object.entries(summary.tx_types||{}).sort((a,b)=>a[0].localeCompare(b[0]));
      tbody.innerHTML=entries.map(([t,v])=>`<tr><td><span class="pill">${t}</span></td><td>${v.count||0}</td><td>${v.gas_used||0}</td><td>${v.avg_gas_price_gwei||0}</td><td>${v.eth_value_sum_eth||0} ETH</td></tr>`).join("");
      renderCharts();
    }

    const tokensSeen = new Set();
    let tokenCache = {};
    function loadTokenCache(){ try { tokenCache = JSON.parse(localStorage.getItem(tokenKey)||"{}"); } catch { tokenCache = {}; } }
    function saveTokenCache(){ localStorage.setItem(tokenKey, JSON.stringify(tokenCache)); renderTokenTable(); }
    function renderTokenTable(){
      const tbody = $("#tokenTable tbody");
      const addrs = Object.keys(tokenCache).sort();
      tbody.innerHTML = addrs.map(a=>{
        const m = tokenCache[a] || {};
        return `<tr><td><code>${a}</code></td><td>${m.symbol||""}</td><td>${m.name||""}</td><td>${m.decimals??""}</td></tr>`;
      }).join("");
    }
    loadTokenCache(); renderTokenTable();

    function updateProgressUI(doneBlocks, totalBlocks, lastBlock){
      updateProgress(doneBlocks, totalBlocks);
      const elapsed = (Date.now()-runStartMs)/1000;
      const rate = doneBlocks>0 ? elapsed/doneBlocks : 0;
      const remaining = Math.max(0, (totalBlocks - doneBlocks) * rate);
      setBlockProgress(lastBlock, startBlockVal + totalBlocks - 1, remaining);
    }

    const SIG_TRANSFER = Web3.utils.keccak256("Transfer(address,address,uint256)").toLowerCase();
    const SIG_ERC1155_SINGLE = Web3.utils.keccak256("TransferSingle(address,address,address,uint256,uint256)").toLowerCase();
    const SIG_ERC1155_BATCH = Web3.utils.keccak256("TransferBatch(address,address,address,uint256[],uint256[])").toLowerCase();

    async function scanLogsTokens(start, end, stepBlocks=2000) {
      const preset = presets[providerProfile.value] || {};
      const step = preset.logsStep || stepBlocks;
      const totalBlocks = end - start + 1;
      const ranges = [];
      for (let s=start; s<=end; s += step) { ranges.push([s, Math.min(end, s+step-1)]); }
      let c20=0, c721=0, c1155=0;
      const tokenTxHashes = new Set();
      for (let i=0; i<ranges.length; i++) {
        if (cancelRequested) break;
        const [a,b] = ranges[i];
        try {
          const logs = await rpcCall(web3.eth.getPastLogs, [{ fromBlock: a, toBlock: b, topics: [SIG_TRANSFER] }]);
          for (const lg of logs) {
            if (lg.address) tokensSeen.add(lg.address.toLowerCase());
            if (lg.transactionHash) tokenTxHashes.add(lg.transactionHash.toLowerCase());
            if (lg.data && lg.data !== "0x") c20++; else c721++;
          }
        } catch {}
        try {
          const l1 = await rpcCall(web3.eth.getPastLogs, [{ fromBlock: a, toBlock: b, topics: [SIG_ERC1155_SINGLE] }]);
          const l2 = await rpcCall(web3.eth.getPastLogs, [{ fromBlock: a, toBlock: b, topics: [SIG_ERC1155_BATCH] }]);
          for (const lg of (l1||[])) { if (lg.address) tokensSeen.add(lg.address.toLowerCase()); if (lg.transactionHash) tokenTxHashes.add(lg.transactionHash.toLowerCase()); }
          for (const lg of (l2||[])) { if (lg.address) tokensSeen.add(lg.address.toLowerCase()); if (lg.transactionHash) tokenTxHashes.add(lg.transactionHash.toLowerCase()); }
          c1155 += (l1?.length||0) + (l2?.length||0);
        } catch {}
        updateProgressUI(Math.min(b, end) - start + 1, totalBlocks, b);
        beat(`logs ${a}-${b}`);
      }
      return {erc20:c20, erc721:c721, erc1155:c1155, tokenTxHashes};
    }

    let runStartMs = 0;

    async function runProfiler(){
      if (!(await connectRPC())) return;
      cancelRequested = false; disableRunUI(true); lastHeartbeat = Date.now(); runStartMs = Date.now();
      runStatus.textContent = "Runningâ€¦";
      const start=Number(startBlockEl.value), end=Number(endBlockEl.value), page=Math.max(1,Number(pageSize.value));
      startBlockVal = start;
      const doSkip=!!skipContract.checked; const txCapN=Number(txCap.value||"0")||null;
      if(!Number.isFinite(start)||!Number.isFinite(end)||end<start){ runStatus.textContent="Invalid range"; disableRunUI(false); return; }
      const blocksTotal=end-start+1;
      const DEFAULT_TYPES=["eth_transfer","contract_creation","erc20_transfer","erc721_transfer","erc1155_transfer","other_contract_call","mixed_token_activity","other_eoa_call"];
      const txTypeStats={}; const codeCache={};

      tokensSeen.clear();
      perBlockRows = [];

      let tokenHashSet = null;
      if (logsOnly.checked || dualPass.checked) {
        runStatus.textContent = "Pass 1: logs scanâ€¦";
        const tokens = await scanLogsTokens(start, end, Math.max(500, page*10));
        tokenHashSet = tokens.tokenTxHashes;
        if (logsOnly.checked && !dualPass.checked) {
          const totalTok = tokens.erc20 + tokens.erc721 + tokens.erc1155;
          summary = {
            start_block:start,
            end_block:end,
            chain_id:Number(await withRetry(()=> web3.eth.getChainId())),
            block_count:blocksTotal,
            total_tx: totalTok,
            tx_types: {
              erc20_transfer:{count:tokens.erc20,gas_used:0,avg_gas_price_gwei:0,eth_value_sum_eth:0},
              erc721_transfer:{count:tokens.erc721,gas_used:0,avg_gas_price_gwei:0,eth_value_sum_eth:0},
              erc1155_transfer:{count:tokens.erc1155,gas_used:0,avg_gas_price_gwei:0,eth_value_sum_eth:0},
              contract_creation:{count:0,gas_used:0,avg_gas_price_gwei:0,eth_value_sum_eth:0},
              other_contract_call:{count:0,gas_used:0,avg_gas_price_gwei:0,eth_value_sum_eth:0},
              mixed_token_activity:{count:0,gas_used:0,avg_gas_price_gwei:0,eth_value_sum_eth:0},
              eth_transfer:{count:0,gas_used:0,avg_gas_price_gwei:0,eth_value_sum_eth:0},
              other_eoa_call:{count:0,gas_used:0,avg_gas_price_gwei:0,eth_value_sum_eth:0}
            }
          };
          renderTables();
          runStatus.textContent="Logs scan complete";
          disableRunUI(false);
          await autoResolveTopTokens();
          return;
        }
      }

      runStatus.textContent = dualPass.checked ? "Pass 2: receipts/classifyâ€¦" : "Running (full)â€¦";
      let totalTx=0;
      let doneBlocks = 0;
      for(let cur=start; cur<=end; cur+=page){
        if (cancelRequested) break;
        const chunkEnd=Math.min(end,cur+page-1);
        const blockNums=[]; for(let b=cur;b<=chunkEnd;b++) blockNums.push(b);
        const blocks = await Promise.all(blockNums.map(b => rpcCall(web3.eth.getBlock, [b, true]).catch(()=>null)));
        if(!doSkip){
          const addrs=[]; for(const blk of blocks){ if(!blk) continue; for(const tx of (blk.transactions||[])){ if(tx.to){ const a=tx.to.toLowerCase(); if(codeCache[a]===undefined) addrs.push(a); } } }
          const uniq=[...new Set(addrs)];
          await Promise.all(uniq.map(a=> rpcCall(web3.eth.getCode, [a]).then(c=>{ codeCache[a]=!!(c&&c!=="0x"&&c!=="0x00");}).catch(()=>{codeCache[a]=true;})));
        }
        for(const blk of blocks){
          if (cancelRequested) break;
          if(!blk) continue;
          const txs=blk.transactions||[];

          let receipts = new Array(txs.length).fill(null);
          if (dualPass.checked && tokenHashSet) {
            await Promise.all(txs.map(async (tx, i) => {
              const isToken = tokenHashSet.has((tx.hash||"").toLowerCase());
              if (!isToken) { try { receipts[i] = await rpcCall(web3.eth.getTransactionReceipt, [tx.hash]); } catch {} }
            }));
          } else {
            receipts = await Promise.all(txs.map(tx=> rpcCall(web3.eth.getTransactionReceipt, [tx.hash]).catch(()=>null)));
          }

          let blockCounts={}; let blockGasUsed=0n;
          for(let i=0;i<txs.length;i++){
            if (cancelRequested) break;
            const tx=txs[i]; let rc=receipts[i];
            if (!rc && dualPass.checked && tokenHashSet && tokenHashSet.has((tx.hash||"").toLowerCase())) {
              rc = { logs: [{ topics: [SIG_TRANSFER], data: tx.input && tx.input !== "0x" ? "0x01" : "0x" }], gasUsed: 0 };
            }
            if(!rc) continue;
            totalTx+=1; const gasUsed=BigInt(rc.gasUsed||0); blockGasUsed+=gasUsed;

            const topics=(rc.logs||[]);
            let erc20=0,erc721=0,erc1155=0;
            for(const lg of topics){
              if(!lg.topics||!lg.topics.length) continue;
              const t0=(lg.topics[0]||"").toLowerCase();
              if (lg.address) tokensSeen.add(lg.address.toLowerCase());
              if(t0===SIG_TRANSFER){ if (lg.data && lg.data!=="0x") erc20++; else erc721++; }
              else if(t0===SIG_ERC1155_SINGLE||t0===SIG_ERC1155_BATCH){ erc1155++; }
            }
            let typ="other_contract_call";
            if(!tx.to) typ="contract_creation";
            else if (erc20>0&&erc721===0&&erc1155===0) typ="erc20_transfer";
            else if (erc721>0&&erc20===0&&erc1155===0) typ="erc721_transfer";
            else if (erc1155>0&&erc20===0&&erc721===0) typ="erc1155_transfer";
            else if (erc20||erc721||erc1155) typ="mixed_token_activity";
            else if (BigInt(tx.value||0)>0n) typ="eth_transfer";
            if(typ==="other_contract_call" && !skipContract.checked && tx.to){
              const a=tx.to.toLowerCase(); typ = (a && a in codeCache ? (codeCache[a]?"other_contract_call":"other_eoa_call") : "other_contract_call");
            }
            const s=(txTypeStats[typ] ||= {count:0,gas_used:0,gas_price_wei_sum:0n,eth_value_wei_sum:0n});
            s.count+=1; s.gas_used+=Number(gasUsed);
            blockCounts[typ]=(blockCounts[typ]||0)+1;
            if(txCapN && totalTx>=txCapN) break;
          }
          perBlockRows.push([blk.number, blk.timestamp, txs.length, DEFAULT_TYPES.map(t=>blockCounts[t]||0).join("|"), Number(blockGasUsed), Number(blk.gasLimit||0)]);
          doneBlocks += 1;
          updateProgressUI(doneBlocks, blocksTotal, blk.number);
          beat(`block ${blk.number}`);
        }
        if(txCapN && totalTx>=txCapN) break;
        beat(`batch ${cur}-${chunkEnd}`);
      }

      const tx_types={};
      for(const [k,v] of Object.entries(txTypeStats)){
        const avgGwei=v.count ? (v.gas_price_wei_sum? Number(v.gas_price_wei_sum)/v.count/1e9 : 0) : 0;
        tx_types[k]={ count:v.count, gas_used:v.gas_used, avg_gas_price_gwei: Math.round(avgGwei*10000)/10000, eth_value_sum_eth: 0 };
      }
      summary={
        start_block:start,
        end_block:end,
        chain_id:Number(await withRetry(()=> web3.eth.getChainId())),
        block_count:blocksTotal,
        total_tx: (Object.values(txTypeStats).reduce((a,v)=>a+v.count,0)),
        tx_types
      };
      renderTables();
      runStatus.textContent = cancelRequested ? "Stopped." : "Done.";
      disableRunUI(false);
      beat("done");

      await autoResolveTopTokens();
    }

    function stopRun(){ cancelRequested = true; runStatus.textContent = "Stoppingâ€¦"; beat("stop requested"); }

    $("#connectBtn").addEventListener("click", connectRPC);
    $("#runBtn").addEventListener("click", runProfiler);
    $("#stopBtn").addEventListener("click", stopRun);

    function dl(name, text, mime="application/octet-stream"){
      const a=document.createElement("a");
      a.href=URL.createObjectURL(new Blob([text],{type:mime}));
      a.download=name;
      document.body.appendChild(a);
      a.click();
      a.remove();
    }

    $("#exportJson").addEventListener("click", ()=>{
      if(!summary){ runStatus.textContent="Nothing to export yet."; return; }
      dl("summary.json", JSON.stringify(summary,null,2), "application/json");
    });
    $("#exportCsv").addEventListener("click", ()=>{
      if(!perBlockRows.length){ runStatus.textContent="No per-block data yet."; return; }
      const header=["block_number","timestamp","tx_count","eth_transfer","contract_creation","erc20_transfer","erc721_transfer","erc1155_transfer","other_contract_call","mixed_token_activity","other_eoa_call","block_gas_used","block_gas_limit"];
      const lines=[header.join(",")].concat(perBlockRows.map(r=>r.join(",")));
      dl("per_block.csv", lines.join("\n"), "text/csv");
    });
    $("#exportNdjson").addEventListener("click", ()=>{
      if(!perBlockRows.length){ runStatus.textContent="No per-block data yet."; return; }
      const TYPES=["eth_transfer","contract_creation","erc20_transfer","erc721_transfer","erc1155_transfer","other_contract_call","mixed_token_activity","other_eoa_call"];
      const lines = perBlockRows.map(([num, ts, txcount, counts, gasUsed, gasLimit])=>{
        const arr = (counts||"").split("|").map(x=>parseInt(x||"0",10));
        const obj = { block_number:num, timestamp:ts, tx_count:txcount, gas_used:gasUsed, gas_limit:gasLimit };
        for (let i=0;i<TYPES.length;i++){ obj[TYPES[i]] = arr[i]||0; }
        return JSON.stringify(obj);
      });
      dl("per_block.ndjson", lines.join("\n"), "application/x-ndjson");
    });

    function inferBaseFeeFromAvg(avgGwei, tipDefault){ const base = Math.max((avgGwei||0) - (tipDefault||2), 1); return Math.round(base*10)/10; }
    function estimateSlots(){
      if (perBlockRows.length>=2){
        const first=perBlockRows[0][1];
        const last=perBlockRows[perBlockRows.length-1][1];
        const dur = Math.max(1, (last-first));
        return Math.max(1, Math.round(dur/12));
      }
      const blocks = (summary?.block_count)||1;
      return Math.max(1, Math.round(blocks));
    }
    function mapTypeToScenario(type){
      if (type==="eth_transfer") return "eoatx";
      if (type==="erc20_transfer") return "erctx";
      if (type==="contract_creation") return "deploytx";
      return "calltx";
    }
    function buildScenarioObjects(){
      const tip = 2;
      const namePrefix = "profiled";
      const seed = "evm-profiler";
      const maxWallets = 200;
      const pendingMult = 2;
      const refillAmount = "1000000000000000000";
      const refillBalance = "500000000000000000";
      const refillInterval = 600;
      const ethAmount = "100000000000000";
      const types = Object.entries(summary.tx_types||{});
      const totalCount = types.reduce((a,[,v])=> a + (v.count||0), 0) || 1;
      const slots = estimateSlots();
      const agg = {};
      for (const [t, v] of types){
        const scenario = mapTypeToScenario(t);
        const share = (v.count||0) / totalCount;
        const throughput = Math.max(0, Math.round((summary.total_tx||0) * share / slots));
        const base = inferBaseFeeFromAvg(v.avg_gas_price_gwei||0, tip);
        if (!agg[scenario]) agg[scenario] = { count:0, throughput:0, base_gwei:0, types:[] };
        agg[scenario].count += (v.count||0);
        agg[scenario].throughput += throughput;
        agg[scenario].base_gwei = Math.max(agg[scenario].base_gwei, base);
        agg[scenario].types.push({ type: t, share: Math.round(share*1000)/10, avg_gwei: v.avg_gas_price_gwei||0 });
      }
      const scenarios = [];
      for (const [scenario, info] of Object.entries(agg)){
        if (scenario === "calltx") continue;
        scenarios.push({
          scenario,
          name: `${namePrefix}-${scenario}`,
          description: `Auto-generated from EVM Profiler. Types: ${info.types.map(x=>x.type).join(", ")}`,
          config: {
            seed,
            refill_amount: refillAmount,
            refill_balance: refillBalance,
            refill_interval: refillInterval,
            throughput: Math.round(info.throughput),
            max_pending: Math.max(1, Math.round((info.throughput||0) * pendingMult)),
            max_wallets: maxWallets,
            base_fee: info.base_gwei || 1,
            tip_fee: tip,
            ...(scenario==="eoatx" ? { amount: ethAmount } : {})
          }
        });
      }
      const callAgg = agg["calltx"];
      if (callAgg) {
        scenarios.push({
          scenario: "calltx",
          name: `${namePrefix}-calltx`,
          description: `Auto-generated from EVM Profiler. Types: ${callAgg.types.map(x=>x.type).join(", ")}`,
          config: {
            seed,
            refill_amount: refillAmount,
            refill_balance: refillBalance,
            refill_interval: refillInterval,
            throughput: Math.round(callAgg.throughput),
            max_pending: Math.max(1, Math.round((callAgg.throughput||0) * pendingMult)),
            max_wallets: maxWallets,
            base_fee: callAgg.base_gwei || 1,
            tip_fee: tip
          }
        });
      }
      return scenarios;
    }
    function toYaml(obj){
      const L=[];
      L.push(`- scenario: ${obj.scenario}`);
      L.push(`  name: "${obj.name}"`);
      L.push(`  description: "${obj.description.replace(/"/g,'\\"')}"`);
      L.push(`  config:`);
      const cfg=obj.config||{};
      for(const [k,v] of Object.entries(cfg)){
        L.push(`    ${k}: ${v}`);
      }
      return L.join("\n");
    }
    $("#exportSpamoor").addEventListener("click", ()=>{
      if (!summary) { runStatus.textContent = "Run profiler first."; return; }
      const scenarios = buildScenarioObjects();
      const mode = document.querySelector('input[name="yamlMode"]:checked').value;
      if (mode === "single") {
        const yaml = scenarios.map(toYaml).join("\n\n");
        dl("spamoor_scenarios.yaml", yaml, "text/yaml");
      } else {
        for (const sc of scenarios) {
          const yaml = toYaml(sc);
          const fname = `spamoor_${sc.scenario}.yaml`;
          dl(fname, yaml, "text/yaml");
        }
      }
    });
    function strToUint8(s){ const enc = new TextEncoder(); return enc.encode(s); }
    function numToBytesLE(n, len){ const a=new Uint8Array(len); for (let i=0;i<len;i++){ a[i]=n & 0xff; n>>=8; } return a; }
    function crc32(buf){ let c = ~0; for (let i=0;i<buf.length;i++){ c ^= buf[i]; for (let k=0;k<8;k++){ c = (c>>>1) ^ (0xEDB88320 & (~(c&1)+1)); } } return ~c >>> 0; }
    function makeZip(files){
      const LFH_SIG = 0x04034b50, CD_SIG = 0x02014b50, EOCD_SIG=0x06054b50;
      let chunks = []; let central = []; let offset = 0;
      for (const f of files){
        const nameBytes = strToUint8(f.name);
        const data = f.data;
        const crc = crc32(data);
        const lfh = new Uint8Array(30 + nameBytes.length);
        let p=0;
        lfh.set(numToBytesLE(LFH_SIG,4), p); p+=4;
        lfh.set(numToBytesLE(20,2), p); p+=2;
        lfh.set(numToBytesLE(0,2), p); p+=2;
        lfh.set(numToBytesLE(0,2), p); p+=2;
        lfh.set(numToBytesLE(0,2), p); p+=2;
        lfh.set(numToBytesLE(0,2), p); p+=2;
        lfh.set(numToBytesLE(crc,4), p); p+=4;
        lfh.set(numToBytesLE(data.length,4), p); p+=4;
        lfh.set(numToBytesLE(data.length,4), p); p+=4;
        lfh.set(numToBytesLE(nameBytes.length,2), p); p+=2;
        lfh.set(numToBytesLE(0,2), p); p+=2;
        lfh.set(nameBytes, p); p+=nameBytes.length;
        chunks.push(lfh, data);

        const cdh = new Uint8Array(46 + nameBytes.length);
        p=0;
        cdh.set(numToBytesLE(CD_SIG,4), p); p+=4;
        cdh.set(numToBytesLE(20,2), p); p+=2;
        cdh.set(numToBytesLE(20,2), p); p+=2;
        cdh.set(numToBytesLE(0,2), p); p+=2;
        cdh.set(numToBytesLE(0,2), p); p+=2;
        cdh.set(numToBytesLE(0,2), p); p+=2;
        cdh.set(numToBytesLE(0,2), p); p+=2;
        cdh.set(numToBytesLE(0,2), p); p+=2;
        cdh.set(numToBytesLE(crc,4), p); p+=4;
        cdh.set(numToBytesLE(data.length,4), p); p+=4;
        cdh.set(numToBytesLE(data.length,4), p); p+=4;
        cdh.set(numToBytesLE(nameBytes.length,2), p); p+=2;
        cdh.set(numToBytesLE(0,2), p); p+=2;
        cdh.set(numToBytesLE(0,2), p); p+=2;
        cdh.set(numToBytesLE(0,2), p); p+=2;
        cdh.set(numToBytesLE(0,2), p); p+=2;
        cdh.set(numToBytesLE(offset,4), p); p+=4;
        cdh.set(nameBytes, p); p+=nameBytes.length;
        central.push({buf: cdh});
        offset += lfh.length + data.length;
      }
      const centralBlob = central.reduce((acc, x)=>{
        const n = new Uint8Array(acc.length + x.buf.length);
        n.set(acc,0);
        n.set(x.buf, acc.length);
        return n;
      }, new Uint8Array(0));
      const eocd = new Uint8Array(22); let p=0;
      eocd.set(numToBytesLE(EOCD_SIG,4), p); p+=4;
      eocd.set(numToBytesLE(0,2), p); p+=2;
      eocd.set(numToBytesLE(0,2), p); p+=2;
      const entries = central.length;
      eocd.set(numToBytesLE(entries,2), p); p+=2;
      eocd.set(numToBytesLE(entries,2), p); p+=2;
      eocd.set(numToBytesLE(centralBlob.length,4), p); p+=4;
      const centralOffset = offset;
      eocd.set(numToBytesLE(centralOffset,4), p); p+=4;
      eocd.set(numToBytesLE(0,2), p); p+=2;

      let totalLen = offset + centralBlob.length + eocd.length;
      const out = new Uint8Array(totalLen);
      let w=0;
      for (const c of chunks) { out.set(c, w); w += c.length; }
      out.set(centralBlob, w); w += centralBlob.length;
      out.set(eocd, w);
      return new Blob([out], {type: "application/zip"});
    }
    $("#exportSpamoorZip").addEventListener("click", ()=>{
      if (!summary) { runStatus.textContent = "Run profiler first."; return; }
      const scenarios = buildScenarioObjects();
      const files = scenarios.map(sc => ({ name: `spamoor_${sc.scenario}.yaml`, data: (new TextEncoder()).encode(toYaml(sc)) }));
      const zip = makeZip(files);
      const a = document.createElement("a"); a.href = URL.createObjectURL(zip); a.download = "spamoor_scenarios.zip"; document.body.appendChild(a); a.click(); a.remove();
    });

    const tokenInput = $("#tokenInput");
    const tokenStatus = $("#tokenStatus");
    $("#collectTokens").addEventListener("click", ()=>{
      const arr = Array.from(tokensSeen);
      tokenInput.value = arr.join("\n");
    });

    function renderTokenStatus(msg, ok=true){
      tokenStatus.textContent = msg;
      tokenStatus.style.color = ok ? "#9aa4b2" : "#ef4444";
    }

    const ERC20_ABI = [
      {"constant":true,"inputs":[],"name":"name","outputs":[{"name":"","type":"string"}],"type":"function"},
      {"constant":true,"inputs":[],"name":"symbol","outputs":[{"name":"","type":"string"}],"type":"function"},
      {"constant":true,"inputs":[],"name":"decimals","outputs":[{"name":"","type":"uint8"}],"type":"function"}
    ];

    async function resolveOneToken(addr){
      try{
        const c = new web3.eth.Contract(ERC20_ABI, addr);
        const [name, symbol, decimals] = await Promise.all([
          withRetry(()=> c.methods.name().call()),
          withRetry(()=> c.methods.symbol().call()),
          withRetry(()=> c.methods.decimals().call())
        ]);
        return {address: addr, name: (name||"").toString(), symbol: (symbol||"").toString(), decimals: Number(decimals)||0};
      }catch(e){
        return {address: addr, name: "", symbol: "", decimals: null, error: e?.message || "call failed"};
      }
    }

    function uniqAddresses(lines){
      const set = new Set();
      for (const raw of lines){
        const a = (raw||"").trim();
        if (!a) continue;
        if (/^0x[a-fA-F0-9]{40}$/.test(a)) set.add(Web3.utils.toChecksumAddress(a));
      }
      return Array.from(set);
    }

    $("#resolveTokens").addEventListener("click", async ()=>{
      if (!web3){ renderTokenStatus("Connect RPC first.", false); return; }
      const list = uniqAddresses((tokenInput.value||"").split(/\r?\n/));
      if (!list.length){ renderTokenStatus("No addresses provided.", false); return; }
      renderTokenStatus(`Resolving ${list.length} token(s)â€¦`);
      for (let i=0;i<list.length;i++){
        const a = list[i];
        try{
          const meta = await resolveOneToken(a);
          tokenCache[a] = { symbol: meta.symbol, name: meta.name, decimals: meta.decimals };
          renderTokenStatus(`Resolved ${i+1}/${list.length}â€¦`);
          renderTokenTable();
        }catch(e){
          renderTokenStatus(`Error on ${a}: ${e?.message||e}`, false);
        }
      }
      saveTokenCache();
      renderTokenStatus("Done.");
    });

    $("#exportTokenCache").addEventListener("click", ()=>{
      const text = JSON.stringify(tokenCache, null, 2);
      dl("token_cache.json", text, "application/json");
    });
    $("#importTokenCache").addEventListener("click", ()=> $("#importTokenFile").click());
    $("#importTokenFile").addEventListener("change", (e)=>{
      const f = e.target.files && e.target.files[0];
      if (!f) return;
      const reader = new FileReader();
      reader.onload = ()=>{
        try{
          tokenCache = JSON.parse(reader.result);
          saveTokenCache();
          renderTokenStatus("Cache imported.");
        } catch(e){
          renderTokenStatus("Invalid JSON.", false);
        }
      };
      reader.readAsText(f);
      e.target.value = "";
    });

    async function autoResolveTopTokens(){
      if (!web3) return;
      const addrs = Array.from(tokensSeen || [])
        .map(a => Web3.utils.toChecksumAddress(a))
        .filter(a => !(a in tokenCache));
      if (!addrs.length) return;
      const MAX_AUTO = 12;
      const sample = addrs.slice(0, MAX_AUTO);
      renderTokenStatus(`Auto-resolving ${sample.length} token(s)â€¦`);
      for (let i=0; i<sample.length; i++){
        try{
          const meta = await resolveOneToken(sample[i]);
          tokenCache[sample[i]] = { symbol: meta.symbol, name: meta.name, decimals: meta.decimals };
          renderTokenTable();
          renderTokenStatus(`Auto-resolved ${i+1}/${sample.length}â€¦`);
        } catch(e){
          // ignore per-token errors
        }
      }
      saveTokenCache();
      renderTokenStatus("Token metadata updated from run.");
    }
  </script>
</body>
</html>
