async function runProfiler() {
  errorStatus.textContent = "";
  try {
    if (!(await connectRPC())) return;
    cancelRequested = false;
    disableRunUI(true);
    lastHeartbeat = Date.now();
    runStartMs = Date.now();
    runStatus.textContent = "Running…";

    const start = Number(startBlockEl.value);
    const end   = Number(endBlockEl.value);
    const page  = Math.max(1, Number(pageSize.value));
    startBlockVal = start;

    const doSkip  = !!skipContract.checked;
    const txCapN  = Number(txCap.value || "0") || null;

    if (!Number.isFinite(start) || !Number.isFinite(end) || end < start) {
      runStatus.textContent = "Invalid range";
      disableRunUI(false);
      return;
    }

    const blocksTotal = end - start + 1;

    // Always have a stub summary so UI can render *something*
    summary = {
      start_block: start,
      end_block:   end,
      chain_id:    null,
      block_count: blocksTotal,
      total_tx:    0,
      tx_types: {}
    };

    const DEFAULT_TYPES = [
      "eth_transfer",
      "contract_creation",
      "erc20_transfer",
      "erc721_transfer",
      "erc1155_transfer",
      "other_contract_call",
      "mixed_token_activity",
      "other_eoa_call"
    ];
    const txTypeStats = {};
    const codeCache   = {};

    tokensSeen.clear();
    perBlockRows = [];

    // ---- PASS 1: logs-only / dual-pass logs scan ----
    let tokenHashSet = null;
    if (logsOnly.checked || dualPass.checked) {
      runStatus.textContent = "Pass 1: logs scan…";
      const tokens = await scanLogsTokens(start, end, Math.max(500, page * 10));
      tokenHashSet = tokens.tokenTxHashes;

      if (logsOnly.checked && !dualPass.checked) {
        const totalTok = tokens.erc20 + tokens.erc721 + tokens.erc1155;
        // Finish stub summary and render immediately
        summary.chain_id = Number(await withRetry(() => web3.eth.getChainId()));
        summary.total_tx = totalTok;
        summary.tx_types = {
          erc20_transfer:      { count: tokens.erc20, gas_used: 0, avg_gas_price_gwei: 0, eth_value_sum_eth: 0 },
          erc721_transfer:     { count: tokens.erc721, gas_used: 0, avg_gas_price_gwei: 0, eth_value_sum_eth: 0 },
          erc1155_transfer:    { count: tokens.erc1155, gas_used: 0, avg_gas_price_gwei: 0, eth_value_sum_eth: 0 },
          contract_creation:   { count: 0,           gas_used: 0, avg_gas_price_gwei: 0, eth_value_sum_eth: 0 },
          other_contract_call: { count: 0,           gas_used: 0, avg_gas_price_gwei: 0, eth_value_sum_eth: 0 },
          mixed_token_activity:{ count: 0,           gas_used: 0, avg_gas_price_gwei: 0, eth_value_sum_eth: 0 },
          eth_transfer:        { count: 0,           gas_used: 0, avg_gas_price_gwei: 0, eth_value_sum_eth: 0 },
          other_eoa_call:      { count: 0,           gas_used: 0, avg_gas_price_gwei: 0, eth_value_sum_eth: 0 }
        };
        renderTables();
        runStatus.textContent = "Logs scan complete";
        disableRunUI(false);
        // kick off token metadata in the background (don’t block UI)
        setTimeout(() => { autoResolveTopTokens().catch(console.error); }, 0);
        return;
      }
    }

    // ---- PASS 2: full receipts/classification ----
    runStatus.textContent = dualPass.checked ? "Pass 2: receipts/classify…" : "Running (full)…";
    let totalTx   = 0;
    let doneBlocks = 0;

    for (let cur = start; cur <= end; cur += page) {
      if (cancelRequested) break;
      const chunkEnd = Math.min(end, cur + page - 1);
      const blockNums = [];
      for (let b = cur; b <= chunkEnd; b++) blockNums.push(b);

      const blocks = await Promise.all(
        blockNums.map(b => rpcCall(web3.eth.getBlock, [b, true]).catch(() => null))
      );

      // prefetch code if not skipping
      if (!doSkip) {
        const addrs = [];
        for (const blk of blocks) {
          if (!blk) continue;
          for (const tx of (blk.transactions || [])) {
            if (tx.to) {
              const a = tx.to.toLowerCase();
              if (codeCache[a] === undefined) addrs.push(a);
            }
          }
        }
        const uniq = [...new Set(addrs)];
        await Promise.all(
          uniq.map(a =>
            rpcCall(web3.eth.getCode, [a])
              .then(c => { codeCache[a] = !!(c && c !== "0x" && c !== "0x00"); })
              .catch(() => { codeCache[a] = true; })
          )
        );
      }

      for (const blk of blocks) {
        if (cancelRequested) break;
        if (!blk) continue;
        const txs = blk.transactions || [];

        let receipts = new Array(txs.length).fill(null);
        if (dualPass.checked && tokenHashSet) {
          await Promise.all(
            txs.map(async (tx, i) => {
              const isToken = tokenHashSet.has((tx.hash || "").toLowerCase());
              if (!isToken) {
                try { receipts[i] = await rpcCall(web3.eth.getTransactionReceipt, [tx.hash]); }
                catch {}
              }
            })
          );
        } else {
          receipts = await Promise.all(
            txs.map(tx =>
              rpcCall(web3.eth.getTransactionReceipt, [tx.hash]).catch(() => null)
            )
          );
        }

        let blockCounts   = {};
        let blockGasUsed  = 0n;

        for (let i = 0; i < txs.length; i++) {
          if (cancelRequested) break;
          const tx = txs[i];
          let rc   = receipts[i];

          // synthetic receipt for dualPass token activity
          if (!rc && dualPass.checked && tokenHashSet &&
              tokenHashSet.has((tx.hash || "").toLowerCase())) {
            rc = {
              logs: [{ topics: [SIG_TRANSFER], data: tx.input && tx.input !== "0x" ? "0x01" : "0x" }],
              gasUsed: 0
            };
          }
          if (!rc) continue;

          totalTx += 1;
          const gasUsed = BigInt(rc.gasUsed || 0);
          blockGasUsed += gasUsed;

          const logs = (rc.logs || []);
          let erc20 = 0, erc721 = 0, erc1155 = 0;

          for (const lg of logs) {
            if (!lg.topics || !lg.topics.length) continue;
            const t0 = (lg.topics[0] || "").toLowerCase();
            if (lg.address) tokensSeen.add(lg.address.toLowerCase());
            if (t0 === SIG_TRANSFER) {
              if (lg.data && lg.data !== "0x") erc20++; else erc721++;
            } else if (t0 === SIG_ERC1155_SINGLE || t0 === SIG_ERC1155_BATCH) {
              erc1155++;
            }
          }

          let typ = "other_contract_call";
          if (!tx.to) typ = "contract_creation";
          else if (erc20 > 0 && erc721 === 0 && erc1155 === 0) typ = "erc20_transfer";
          else if (erc721 > 0 && erc20 === 0 && erc1155 === 0) typ = "erc721_transfer";
          else if (erc1155 > 0 && erc20 === 0 && erc721 === 0) typ = "erc1155_transfer";
          else if (erc20 || erc721 || erc1155) typ = "mixed_token_activity";
          else if (BigInt(tx.value || 0) > 0n) typ = "eth_transfer";

          if (typ === "other_contract_call" && !skipContract.checked && tx.to) {
            const a = tx.to.toLowerCase();
            if (a in codeCache) {
              typ = codeCache[a] ? "other_contract_call" : "other_eoa_call";
            }
          }

          const s = (txTypeStats[typ] ||= {
            count: 0,
            gas_used: 0,
            gas_price_wei_sum: 0n,
            eth_value_wei_sum: 0n
          });
          s.count += 1;
          s.gas_used += Number(gasUsed);
          blockCounts[typ] = (blockCounts[typ] || 0) + 1;

          if (txCapN && totalTx >= txCapN) break;
        }

        perBlockRows.push([
          blk.number,
          blk.timestamp,
          (blk.transactions || []).length,
          DEFAULT_TYPES.map(t => blockCounts[t] || 0).join("|"),
          Number(blockGasUsed),
          Number(blk.gasLimit || 0)
        ]);

        doneBlocks += 1;
        updateProgressUI(doneBlocks, blocksTotal, blk.number);
        beat(`block ${blk.number}`);
      }

      if (txCapN && totalTx >= txCapN) break;
      beat(`batch ${cur}-${chunkEnd}`);
    }

    // ---- finalize summary / UI ----
    const tx_types = {};
    for (const [k, v] of Object.entries(txTypeStats)) {
      const avgGwei = v.count
        ? (v.gas_price_wei_sum ? Number(v.gas_price_wei_sum) / v.count / 1e9 : 0)
        : 0;
      tx_types[k] = {
        count: v.count,
        gas_used: v.gas_used,
        avg_gas_price_gwei: Math.round(avgGwei * 10000) / 10000,
        eth_value_sum_eth: 0
      };
    }

    summary = {
      start_block: start,
      end_block:   end,
      chain_id:    Number(await withRetry(() => web3.eth.getChainId())),
      block_count: blocksTotal,
      total_tx:    Object.values(txTypeStats).reduce((a, v) => a + v.count, 0),
      tx_types
    };

    renderTables();
    runStatus.textContent = cancelRequested ? "Stopped." : "Done.";
    disableRunUI(false);
    beat("done");

    // kick off token metadata resolution *after* UI is unlocked
    setTimeout(() => { autoResolveTopTokens().catch(console.error); }, 0);

  } catch (err) {
    showError(err && err.message ? err.message : err);
    runStatus.textContent = "Error during run.";
    disableRunUI(false);
  }
}
